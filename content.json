{"meta":{"title":"AI WHALE","subtitle":"","description":"A blog dedicated to AI, technology, and innovation.","author":"he0xwhale","url":"https://ai.he0xwhale.xyz","root":"/"},"pages":[{"title":"关于我","date":"2025-07-09T07:41:31.230Z","updated":"2025-07-09T07:41:31.230Z","comments":true,"path":"about/index.html","permalink":"https://ai.he0xwhale.xyz/about/index.html","excerpt":"","text":"你好，欢迎来到我的博客！ 我是一个热爱技术、乐于折腾的创作者，目前正在搭建并维护自己的 Hexo 博客，使用的是美观灵动的 Butterfly 主题。在探索过程中，我对博客的图标、壁纸、Logo 设计等细节都有不少自定义和优化，比如尝试将 AI 编程与吉卜力风格相结合，营造一种温暖又有科技感的氛围。博客内容会围绕我感兴趣的领域展开，包括但不限于： 编程与技术实践 人工智能与应用探索 静态博客优化技巧 开源工具使用心得 我希望这个博客不仅是我的知识笔记和成长记录，也能成为你参考或交流的一个起点。如果你对博客内容有建议，欢迎通过评论或其他方式与我交流！ 邮箱: he0xwhale@gmail.com github: https://github.com/he0xwhale"},{"title":"文章归档","date":"2025-07-04T08:17:51.778Z","updated":"2025-07-04T08:17:51.778Z","comments":true,"path":"archives/index.html","permalink":"https://ai.he0xwhale.xyz/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-07-08T07:26:19.016Z","updated":"2025-07-08T07:26:19.016Z","comments":true,"path":"categories/index.html","permalink":"https://ai.he0xwhale.xyz/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2025-07-09T03:31:07.764Z","updated":"2025-07-09T03:31:07.764Z","comments":false,"path":"friends/index.html","permalink":"https://ai.he0xwhale.xyz/friends/index.html","excerpt":"","text":"欢迎交换友链，请留言或联系我。 友情链接 Hexo 官方文档 Volantis 主题文档"},{"title":"所有标签","date":"2025-07-04T08:17:42.511Z","updated":"2025-07-04T08:17:42.511Z","comments":true,"path":"tags/index.html","permalink":"https://ai.he0xwhale.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录","slug":"07/09/hexo-butterfly-cover-image-debug-story","date":"2025-07-09T07:45:00.000Z","updated":"2025-07-09T07:53:30.680Z","comments":true,"path":"2025/07/09/hexo-butterfly-cover-image-debug-story/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/07/09/hexo-butterfly-cover-image-debug-story/","excerpt":"","text":"在搭建和美化 Hexo 博客的过程中，我们时常会遇到一些看似简单，却足以让人抓狂的“灵异事件”。最近，我就和我的 AI 助手 Roo 经历了一次这样的封面图调试之旅。一个简单的图片不显示问题，我们排查了代码、配置、路径，甚至怀疑人生，最终却发现“真凶”隐藏在一个意想不到的地方。 这篇文章记录了我们完整的调试过程，希望能为同样在 Hexo 世界中探索的你提供一些有价值的参考和避坑指南。 一、问题的提出：不听话的 category_img 和 tag_img最初的问题很简单：我为分类页和标签页设置了封面图，但它们就是不显示。 在 themes/butterfly/_config.yml 中，我的配置如下： 1234567891011# ...# If the banner of page not setting, it will show the default_top_imgdefault_top_img:# ...# Note: category page, not categories pagecategory_img: /images/website/categories.png# Note: tag page, not tags pagetag_img: /images/website/tag.png# ... 奇怪的是，如果我设置了 default_top_img，比如： 1default_top_img: /images/website/bg.png 那么分类页和标签页就会显示 bg.png 这张图片。这说明页面本身能够显示封面图，但 category_img 和 tag_img 这两个配置项被无视了。 二、初步排查：代码逻辑的“完美无缺”我们首先进行了一系列常规的代码层面排查： 检查文件是否存在：确认 /source/images/website/categories.png 和 /source/images/website/tag.png 这两个图片文件确实存在。 检查模板逻辑：我们深入分析了 Butterfly 主题的核心模板文件 themes/butterfly/layout/includes/header/index.pug。通过分析，我们确定了封面图的渲染逻辑。 调试页面变量：通过在模板中输出调试信息，我们发现了一个关键信息：在分类页（/categories/），Hexo 传递给模板的变量 page.type 的值是 categories，但主题内部计算出的 globalPageType 却是 page。 基于这个发现，我们修正了 header/index.pug 的代码，在 case globalPageType 的 when &#39;page&#39; 分支中，增加了对 page.type 的判断： 12345678910// themes/butterfly/layout/includes/header/index.pug// ... when &#x27;page&#x27; if (page.type === &#x27;categories&#x27;) - top_img = returnTopImg(theme.category_img) else if (page.type === &#x27;tags&#x27;) - top_img = returnTopImg(theme.tag_img) else - top_img = page.top_img || theme.default_top_img// ... 这段代码的逻辑非常清晰：当页面类型是 page 时，再检查其具体的 type 属性，如果是 categories 或 tags，就使用对应的图片。 至此，我们确信代码逻辑已经完美。 三、陷入僵局：当 hexo clean 也不管用时然而，最诡异的事情发生了。尽管我们每次修改后都严格执行了 hexo clean 来清除缓存，并使用 Ctrl+Shift+R 硬刷新浏览器，但问题依旧。图片依然不显示，就好像我们的代码修改从未发生过一样。 这让我们一度怀疑是 Pug 模板引擎的渲染问题，甚至尝试了用 JavaScript 动态修改 style 属性等各种“曲线救国”的方法，但都无济于事。 四、最终突破：重启电脑后的“豁然开朗”就在我们几乎要放弃的时候，转机出现了。第二天，我重启了电脑，再次运行 hexo server，然后惊奇地发现——一切都正常了！分类页和标签页的封面图都正确地显示了出来。 这让我们最终定位到了问题的根本原因：Hexo 渲染进程的陈旧缓存。 hexo clean 的局限性：这个命令确实可以清除 public 目录和物理的 db.json 缓存文件。但是，它无法重置正在运行的 hexo server 进程的内存状态。 hexo server 的“幽灵”状态：在我们长时间、高强度的调试过程中，对主题的模板文件 (.pug) 和辅助函数 (.js) 进行了大量修改。这很可能导致了 hexo server 的 Node.js 进程内部状态变得不一致。它可能没有完全重新加载所有模块，或者某些变量的缓存在内存中没有被正确清除。 重启的威力：重启电脑彻底终止了所有进程，包括那个可能已经“精神错乱”的 hexo server 进程。当我们再次启动服务时，一个全新的、干净的进程加载了所有最新的、正确的代码和配置，问题自然就迎刃而解了。 五、经验总结与操作建议这次漫长而曲折的调试过程，给我们带来了宝贵的经验： 养成 hexo clean 的好习惯：在修改任何配置或代码后，执行 hexo clean 永远是第一选择。 重启 hexo server 是必要的：当你修改了主题的 .js 逻辑文件或 .pug 模板文件后，如果 hexo clean 不起作用，请务必停止 (Ctrl+C) 并重新启动 hexo server。这会强制 Hexo 加载一个全新的、干净的运行环境。 浏览器缓存不可忽视：在开发时，善用 Ctrl+Shift+R 硬刷新或在开发者工具中禁用缓存。 独立页面封面图的设置：对于“关于”和“友链”这类独立页面，Butterfly 主题并未提供全局配置项。正确的做法是在对应页面的 Markdown 文件 (source/about/index.md, source/friends/index.md) 的 Front-matter 中添加 top_img 属性来单独指定封面图。 希望这次的“灵异事件”记录，能帮助你在 Hexo 的世界里少走一些弯路。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"问题排查","slug":"博客之旅/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端调试","slug":"前端调试","permalink":"https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ai.he0xwhale.xyz/tags/Debugging/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://ai.he0xwhale.xyz/tags/Butterfly/"}]},{"title":"Hexo Butterfly 主题副标题不显示问题排查与解决","slug":"07/07/hexo-butterfly-subtitle-debug-guide","date":"2025-07-07T08:30:00.000Z","updated":"2025-07-09T07:53:21.669Z","comments":true,"path":"2025/07/07/hexo-butterfly-subtitle-debug-guide/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/07/07/hexo-butterfly-subtitle-debug-guide/","excerpt":"","text":"引言在使用 Hexo 搭建博客并采用 Butterfly 主题时，您可能会遇到一个令人困惑的问题：网站的 &lt;title&gt; 标签中正确显示了站点标题和副标题（例如 “AI whale - Exploring the World of AI”），但在实际的页面内容（尤其是首页的头部区域）中，却只显示了站点标题，而副标题神秘“失踪”了。本文将详细记录这一问题的排查过程，并提供最终的解决方案。 问题现象在浏览器中检查网站首页的 HTML 元素，可以发现 &lt;head&gt; 标签内的 &lt;title&gt; 元素内容是完整的： 1&lt;title&gt;AI whale - Exploring the World of AI&lt;/title&gt; 然而，在 &lt;body&gt; 内部的可见区域，例如 &lt;header&gt; 部分，却只有主标题“AI whale”显示，副标题“Exploring the World of AI”不见踪影。 排查过程 检查全局配置 (_config.yml)首先，我们检查了 Hexo 的全局配置文件 _config.yml，确认 title 和 subtitle 配置项都已正确设置： 123# _config.ymltitle: AI whalesubtitle: &quot;Exploring the World of AI&quot; 这表明网站的元信息是正确的，问题可能出在主题的渲染逻辑上。 定位主题配置文件 (themes/butterfly/_config.yml)Hexo 主题通常有自己的配置文件，这些配置会覆盖或合并全局配置。对于 Butterfly 主题，其配置文件位于 themes/butterfly/_config.yml。我们检查了该文件，发现了 subtitle 相关配置： 123456789# themes/butterfly/_config.yml# ...subtitle: enable: true effect: true # 启用打字机效果 # ... sub: - &quot;从传统编程到AI编程，一刻不停的疲于奔命&quot;# ... 这里注意到 subtitle 被定义为一个对象，其中 enable 为 true，并且 sub 数组中包含了另一个字符串，而不是全局 _config.yml 中的“Exploring the World of AI”。 分析主题渲染逻辑 (themes/butterfly/layout/includes/header/index.pug 和 themes/butterfly/layout/includes/third-party/subtitle.pug)我们进一步深入主题的模板文件，发现主页头部渲染逻辑位于 themes/butterfly/layout/includes/header/index.pug： 12345678910// themes/butterfly/layout/includes/header/index.pug// ...else if globalPageType === &#x27;home&#x27; #site-info h1#site-title=config.title if theme.subtitle.enable // 条件判断 - var loadSubJs = true #site-subtitle span#subtitle // 副标题占位符// ... 而 span#subtitle 的内容填充则是由 themes/butterfly/layout/includes/third-party/subtitle.pug 中的 JavaScript 动态完成的。关键在于该文件中的逻辑： 123456789101112131415161718192021// themes/butterfly/layout/includes/third-party/subtitle.pug- const &#123; effect, source, sub, typed_option &#125; = theme.subtitle// ...script. window.typedJSFn = &#123; init: str =&gt; &#123; // ... (Typed.js 初始化逻辑) &#125;, run: subtitleType =&gt; &#123; // ... &#125;, processSubtitle: (content, extraContents = []) =&gt; &#123; if (!&#123;effect&#125;) &#123; // 如果 effect 为 false，使用 Typed.js // ... &#125; else &#123; // 如果 effect 为 true，直接设置 textContent document.getElementById(&#x27;subtitle&#x27;).textContent = typeof content === &#x27;string&#x27; ? content : (Array.isArray(content) &amp;&amp; content.length &gt; 0 ? content[0] : &#x27;&#x27;) &#125; &#125; &#125;// ... 我们发现，如果 theme.subtitle.effect 为 true，则会直接从 theme.subtitle.sub 数组中获取第一个元素作为副标题文本。 发现配置冲突问题浮出水面：Hexo 在合并全局 _config.yml 和主题 _config.butterfly.yml 时，对于 subtitle 这个配置项，并没有进行深层合并 (deep merge)，而是简单地用全局 _config.yml 中 subtitle 的字符串值（”Exploring the World of AI”）覆盖了主题 _config.butterfly.yml 中 subtitle 的整个对象。 这意味着，当 Pug 模板尝试访问 theme.subtitle.enable 或 theme.subtitle.sub 时，它实际上是在尝试访问字符串 &quot;Exploring the World of AI&quot; 的属性，这必然导致 undefined 或错误。因此，if theme.subtitle.enable 条件始终为 false，导致副标题的 HTML 结构和 JavaScript 逻辑都没有被渲染到最终的 public/index.html 中。 通过在 Pug 模板中输出 theme 对象的完整 JSON 字符串，我们证实了这一点：&quot;subtitle&quot;: &quot;Exploring the World of AI&quot; 确实是 theme 对象中 subtitle 的实际值。 解决方案根本原因是 Hexo 配置的合并机制。要解决此问题，需要确保主题的 subtitle 配置能够正确被解析。 最直接的解决方案是： 将 Hexo 全局配置文件 (_config.yml) 中的 subtitle 配置项移除或注释掉。 123# _config.ymltitle: AI whale# subtitle: &quot;Exploring the World of AI&quot; # 注释掉或删除此行 通过这样做，Hexo 在生成静态文件时，将不再有全局的 subtitle 字符串来覆盖主题的 subtitle 对象。这样，主题 themes/butterfly/_config.yml 中定义的 subtitle 对象（包括 enable: true 和 sub 数组）就会被正确加载和使用，从而使得副标题能够正常显示。 总结本次排查的核心在于理解 Hexo 配置文件的合并机制以及主题渲染逻辑对配置项的依赖。当全局配置与主题配置存在同名但不同类型（字符串 vs. 对象）的配置项时，Hexo 会优先使用全局配置，导致主题的复杂配置无法生效。通过移除冲突的全局配置，我们成功地让主题的副标题功能恢复正常。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ai.he0xwhale.xyz/tags/Debugging/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://ai.he0xwhale.xyz/tags/Butterfly/"},{"name":"Configuration","slug":"Configuration","permalink":"https://ai.he0xwhale.xyz/tags/Configuration/"},{"name":"Front-end","slug":"Front-end","permalink":"https://ai.he0xwhale.xyz/tags/Front-end/"}]},{"title":"Hexo多语言博客导航问题排查全记录","slug":"07/04/hexo-multilingual-guide","date":"2025-07-04T03:00:00.000Z","updated":"2025-07-08T03:19:29.025Z","comments":true,"path":"2025/07/04/hexo-multilingual-guide/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/07/04/hexo-multilingual-guide/","excerpt":"","text":"本文详细记录了在 Hexo 博客中使用 hexo-multiple-language-generate 插件对 Volantis 主题进行多语言国际化时遇到的各种问题，包括目录结构调整、配置文件适配、导航链接错误、样式冲突等，以及从初步尝试到最终放弃该方案的全过程。 国际化需求与初步方案我希望对现有 Hexo 博客进行国际化，支持中文（zh-CN）和英文（en）两种语言。初步方案是利用 hexo-multiple-language-generate 插件，并调整项目结构和配置文件。 核心变动点： 安装插件: hexo-multiple-language-generate。 调整项目结构: 为每种语言创建独立的 source 目录（source-zh/、source-en/）。 Hexo 配置文件: 为每种语言创建独立的 Hexo 配置文件（config.zh.yml、config.en.yml）。 插件配置文件: 在项目根目录创建 hexo-multiple-language.yml。 主题配置文件: 为每种语言创建独立的主题配置文件（config.volantis.zh.yml、config.volantis.en.yml）。 使用新命令: 生成博客时使用 hexo multiple-language-generate。 阶段一：基础配置与内容迁移按照初步方案，我安装了插件，创建了 hexo-multiple-language.yml 配置文件，并调整了目录结构，将中英文内容分别迁移到 source-zh 和 source-en 目录。为了确保英文站点有内容可以生成，我还在 source-en/_posts/ 下手动创建了一篇英文测试文章 hello-world-en.md。 同时，我创建了 config.zh.yml 和 config.en.yml，分别配置了各自的语言、URL、源目录等信息，并确保 public_dir 指向统一的 public 目录，以便插件能正确地将英文内容生成到 public/en/ 子目录下。 阶段二：问题浮现与排查完成基础配置并生成站点后，一系列问题开始出现。 问题一：导航栏文字被挤压当我访问英文站点 http://localhost:5000/en/ 时，导航栏上的链接文字被挤压，只显示图标。通过浏览器开发者工具发现，&lt;a&gt; 标签的 display 属性计算结果为 block。 尝试与解决: 起初尝试通过外部 CSS 文件覆盖样式，但未生效。最终，我直接修改了 themes/volantis/layout/_partial/header.ejs，在导航链接的 &lt;a&gt; 标签中添加行内样式 style=&quot;display: inline-flex; align-items: center;&quot;，成功解决了文字挤压问题。 问题二：导航链接错误这是最核心的问题。在 Volantis 主题的 Hexo 博客中，导航栏上的语言切换链接（“简体中文”和“English”）显示和跳转异常。 具体表现: 当访问英文文章页面（例如 http://localhost:5000/en/hello-world-en/）时，导航栏中的“简体中文”链接本应指向 http://localhost:5000/，却错误地指向了 http://localhost:5000/en/；而“English”链接本应指向 http://localhost:5000/en/，却错误地指向了 http://localhost:5000/en/en/。 初步排查: 我检查了所有相关的配置文件： themes/volantis/layout/_partial/header.ejs：确认了链接是通过 &lt;%- url_for(value.url) %&gt; 动态生成的。 _config.yml 和 config.*.yml：确认了多语言和永久链接的设置。 config.volantis.*.yml：确认了导航菜单的 url 属性值（/ 和 /en/）在配置层面是正确的。 这些检查表明，问题出在 Hexo 的 url_for 辅助函数上。它在渲染链接时，会基于当前页面的 root 路径（如 /en/）对相对路径进行拼接，从而导致了 URL 路径的重复。 阶段三：关键发现与终极解决方案在排查过程中，我偶然发现了一个来自 Butterfly 主题的 switch-language.js 脚本。这个脚本揭示了一个关键信息：在某些主题中，多语言切换并非简单地依赖 url_for 生成的静态链接，而是通过 JavaScript 动态处理的。 该脚本中的 initLanguageSwitchLinks 函数会遍历所有带有特定类（multiple-language-switch）的链接，并为其添加点击事件监听器。当点击发生时，handleLanguageSwitch 函数会被调用，它会根据目标语言，手动构建正确的 URL（例如 http://localhost:5000/ 或 http://localhost:5000/en/）并进行跳转。 这完美解释了为什么 url_for 生成的链接不正确，因为正确的跳转逻辑被设计为由前端 JavaScript 控制。 最终解决方案基于以上发现，最终的解决方案是，结合 switch-language.js 的工作原理，对主题进行以下修改： 修改 EJS 模板: 在 themes/volantis/layout/_partial/header.ejs 中，为语言切换链接的 &lt;li&gt; 或 &lt;a&gt; 标签添加 multiple-language-switch 类。这使得 switch-language.js 能够识别并处理这些链接的点击事件。 123456&lt;!-- 示例：找到生成语言切换链接的地方，添加 class --&gt;&lt;li class=&quot;menu-item menu-item-type-post_type menu-item-object-page multiple-language-switch&quot;&gt; &lt;a href=&quot;&lt;%- url_for(value.url) %&gt;&quot;&gt; ... &lt;/a&gt;&lt;/li&gt; 引入 JS 脚本: 将 switch-language.js 脚本引入到主题中。最稳妥的方法是在 Hexo 的主配置文件 _config.yml 中，通过 inject 选项将其注入到页面底部。 首先，将 switch-language.js 文件放置在 themes/volantis/source/js/ 目录下。 然后，在 _config.yml 中添加注入配置： 123inject: bottom: - &lt;script src=&quot;/js/switch-language.js&quot;&gt;&lt;/script&gt; 通过这些修改，语言切换功能将由 switch-language.js 脚本接管。它会忽略 href 属性中由 url_for 生成的错误链接，并在用户点击时，动态计算并跳转到正确的语言根路径。 虽然通过自己DIY可以实现，但是后续还有需要可以调整的地方，所以，如果想要真正好用，最好还是直接使用buffterfly这类直接支持国际化的主题。 经验总结本次排查和解决 Hexo 多语言导航链接问题的过程，使我深刻认识到： 理解主题和插件的内部工作机制至关重要。 表面上简单的链接问题，背后可能涉及到复杂的 JavaScript 逻辑和前端路由处理。不能只停留在模板和配置层面。 调试是解决问题的关键。 通过分析浏览器开发者工具中的元素、网络请求和控制台日志，可以更准确地定位问题根源。 跨主题借鉴解决方案。 当遇到棘手问题时，参考其他成熟主题（如 Butterfly）对相似功能的实现，可能会带来意想不到的启发。 主题与插件的兼容性是重要考量。 在选择技术栈时，应优先考虑其对目标功能的官方支持和社区适配案例，以减少不必要的开发和调试工作。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"问题排查","slug":"博客之旅/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"多语言","slug":"多语言","permalink":"https://ai.he0xwhale.xyz/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"},{"name":"博客","slug":"博客","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ai.he0xwhale.xyz/tags/JavaScript/"}]},{"title":"从 Hexo 国际化配置还原为默认状态（Volantis 主题完整修复指南）","slug":"07/02/hexo_i_18_n_revert_guide","date":"2025-07-01T16:00:00.000Z","updated":"2025-07-08T03:19:31.237Z","comments":true,"path":"2025/07/02/hexo_i_18_n_revert_guide/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/07/02/hexo_i_18_n_revert_guide/","excerpt":"","text":"在尝试为 Hexo 博客启用多语言功能，搭配 Volantis 主题与 hexo-generator-index-i18n 插件实现 / 显示 zh-CN，/en/ 显示英文分页的过程中，出现了大量错误 首页 Cannot GET / /zh-CN/zh-CN/index.html 等路径嵌套 所有文章混杂分页、不正确语言过滤 页码仍基于总文章数分页（比如 1&#x2F;4） 最终我决定完全撤销国际化支持，恢复 Hexo + Volantis 默认行为，并记录完整还原过程，方便自己或他人参考。 💡 尝试 Hexo 多语言支持过程（失败记录）1. 使用 hexo-generator-index-i18n在根目录 _config.yml 添加配置： 123456index_generator_i18n: per_page: 10 order_by: -date languages: zh-CN: index # 期望生成 /index.html en: en # 生成 /en/index.html 文章结构使用 source/_posts/zh-CN/ 和 source/_posts/en/。 文章 front-matter 添加 lang: zh-CN 或 lang: en。 结果： 多语言页面能访问 /zh-CN/ 和 /en/ 但根目录 / 不会列出全部文章，且分页逻辑混乱 /public/zh-CN/zh-CN/index.html 这种嵌套出现，路径异常 2. 修改 archive.ejs 与 index.ejs 模板尝试用 page.lang 对文章进行语言过滤： 123const currentLang = page.lang || &#x27;zh-CN&#x27;;...site.posts.filter(post =&gt; post.lang === currentLang) 结果： 文章确实被筛选了，但分页总数仍为全局文章数 出现 1/4 页码，但其实该语言下只有 1 篇文章 3. 使用 HTML 重定向方案尝试添加 source/index.html： 1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=/zh-CN/&quot;&gt; 结果： 无效，Hexo build 后根路径仍无首页，或被清空 4. 使用 hexo-generator-redirect 插件1npm install hexo-generator-redirect --save 然后配置： 12redirects: &quot;/&quot;: &quot;/zh-CN/&quot; 结果： 安装失败（依赖 Hexo 5，当前为 Hexo 6.3），或 / 页面失效（Cannot GET &#x2F;） 最终，在对 Hexo、Volantis、分页插件等源码调试后，判断国际化插件目前与 Volantis 的首页分页机制冲突过多，决定彻底撤回。 ✅ 恢复操作步骤1. 还原根目录 _config.yml 配置删除国际化相关配置： 123456index_generator_i18n: ... # ❌ 删除language: zh-CN # ✅ 设置默认语言index_generator: # ✅ 使用默认分页生成器 path: &#x27;&#x27; per_page: 10 order_by: -date 2. 卸载国际化插件123npm uninstall hexo-generator-index-i18nnpm uninstall hexo-generator-redirectnpm install hexo-generator-index 3. 合并文章结构1234mv source/_posts/zh-CN/* source/_posts/mv source/_posts/en/* source/_posts/rm -r source/_posts/zh-CN/rm -r source/_posts/en/ 删除每篇文章的 lang: 字段（可选） 4. 删除语言静态页面及 index.html12rm -rf source/en/ source/zh-CN/rm -f source/index.html source/index.md 5. 恢复 Volantis 模板将 themes/volantis/layout/_partial/archive.ejs 文件内容还原为原始： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;% if (site.posts &amp;&amp; site.posts.length &gt; 0) &#123; %&gt;&lt;section class=&quot;post-list&quot;&gt; &lt;% if (page.current === 1) &#123; %&gt; &lt;% site.posts.filter(post =&gt; post.pin).sort(&#x27;date&#x27;, -1).each(function(post)&#123; %&gt; &lt;div class=&#x27;post-wrapper&#x27;&gt; &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;% site.pages.filter(post =&gt; post.pin).sort(&#x27;date&#x27;, -1).each(function(post)&#123; %&gt; &lt;div class=&#x27;post-wrapper&#x27;&gt; &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;% page.posts.filter(post =&gt; !post.pin).each(function(post)&#123; %&gt; &lt;div class=&#x27;post-wrapper&#x27;&gt; &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt; &lt;/div&gt; &lt;% &#125;) %&gt;&lt;/section&gt; &lt;% if (page.total &gt; 1) &#123; %&gt; &lt;br&gt; &lt;div class=&quot;prev-next&quot;&gt; &lt;% if (page.prev != 0) &#123; %&gt; &lt;a class=&quot;prev&quot; rel=&quot;prev&quot; href=&quot;&lt;%= url_for(page.prev_link) %&gt;&quot;&gt; &lt;section class=&quot;post prev white-box &lt;%- theme.custom_css.body.effect.join(&#x27; &#x27;) %&gt;&quot;&gt; &lt;i class=&quot;fa-solid fa-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&lt;%- __(&#x27;post.prev_page&#x27;) %&gt;&amp;nbsp; &lt;/section&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;p class=&quot;current&quot;&gt; &lt;%= page.current %&gt; / &lt;%= page.total %&gt; &lt;/p&gt; &lt;% if (page.next != 0) &#123; %&gt; &lt;a class=&quot;next&quot; rel=&quot;next&quot; href=&quot;&lt;%= url_for(page.next_link) %&gt;&quot;&gt; &lt;section class=&quot;post next white-box &lt;%- theme.custom_css.body.effect.join(&#x27; &#x27;) %&gt;&quot;&gt; &amp;nbsp;&lt;%- __(&#x27;post.next_page&#x27;) %&gt;&amp;nbsp;&lt;i class=&quot;fa-solid fa-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;/section&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 6. 重新构建1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s ✅ 最终恢复效果 功能 状态 首页 &#x2F; ✅ 显示所有文章，不再跳转 /zh-CN/、/en/ ❌ 不再存在 分页 ✅ 按总文章数分页 模板 ✅ 使用 Volantis 默认逻辑 📌 总结Hexo 当前的分页逻辑与 Volantis 的模板结构，在使用 hexo-generator-index-i18n 时存在以下问题： page.posts 提供的是全局文章数组，分页数量基于所有文章 即便筛选文章显示了部分，分页导航仍照旧分页（出现 1&#x2F;4，2&#x2F;4） Volantis 模板未内建对多语言分页路径的完整支持 插件本身未适配 Hexo 6.x + Volantis 最新模板结构 ⚠️ 建议未来如需中英文独立首页分页，可以考虑： 使用多 Hexo 子站部署 使用标签（如 tag: en）做筛选页 自定义 index 页 + layout 希望本文对未来再次尝试 Hexo 多语言配置有所帮助，也欢迎基于此模板进一步扩展语言支持方案。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"问题排查","slug":"博客之旅/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"多语言","slug":"多语言","permalink":"https://ai.he0xwhale.xyz/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"},{"name":"排障记录","slug":"排障记录","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8E%92%E9%9A%9C%E8%AE%B0%E5%BD%95/"},{"name":"i18n","slug":"i18n","permalink":"https://ai.he0xwhale.xyz/tags/i18n/"},{"name":"国际化","slug":"国际化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"博客恢复","slug":"博客恢复","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"}]},{"title":"一次离奇的VS Code调试经历：当眼见不再为实","slug":"07/01/strange-debug-story","date":"2025-07-01T03:11:00.000Z","updated":"2025-07-08T03:17:43.258Z","comments":true,"path":"2025/07/01/strange-debug-story/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/07/01/strange-debug-story/","excerpt":"","text":"我在开发一个 VS Code 插件时，遇到了一个堪称我职业生涯中最离奇的调试问题。它耗费了我数小时的时间，并最终让我深刻理解了“眼见不一定为实”。 问题的开端一切都始于一个简单的函数。在我的 TypeScript 代码中，有这样一段逻辑： 123456789101112131415// src/commands/removeTargetCommand.tspublic async execute(targetPath?: string): Promise&lt;void&gt; &#123; Logger.log( `RemoveTargetCommand: execute started with targetPath: $&#123;targetPath&#125;` ); // 如果未提供目标路径，则退出 if (!targetPath) &#123; Logger.error(&quot;RemoveTargetCommand: No target path provided&quot;); // ... return; &#125; // ...&#125; 当我在这段代码中进行单步调试时，诡异的事情发生了：调试器的高亮显示，程序首先跳到了 if (!targetPath) 这一行，然后才跳回到 Logger.log(...)。执行顺序看起来完全是颠倒的！ 第一轮排查：Source Map作为一名开发者，我的第一反应是：Source Map 出错了。 Source Map 是连接编译后 JavaScript 和原始 TypeScript 代码的桥梁。如果它出了问题，调试器显示错乱的行号是常有的事。于是，我开始了一系列教科书式的排查： 检查 tsconfig.json：确认 &quot;sourceMap&quot;: true 已开启。 检查 webpack.config.js：确认 devtool: &quot;source-map&quot; 配置正确。 清理并重建：删除了所有编译产物（dist 和 out 目录），并重新运行 npm run compile。 然而，在完成了所有这些操作后，问题依旧。 第二轮排查：日志系统和 JIT 优化既然不是简单的 Source Map 配置问题，我开始怀疑更深层次的原因。 日志系统是异步的吗？ 我检查了 Logger 类的实现。它是完全同步的，不存在任何缓冲或异步操作。排除。 是 JIT 优化导致的吗？ 我怀疑是 V8 引擎的即时编译（JIT）优化（如函数内联）导致了代码重排，从而迷惑了调试器。我甚至写了一个“反优化”的包装函数来包裹日志调用，试图阻止 JIT 的优化。 123456789// 尝试阻止 JIT 优化的临时代码const logWithNoInline = (msg: string) =&gt; &#123; try &#123; let count = 0; for (let i = 0; i &lt; 1; i++) &#123; count++; &#125; if (count &gt; 0) &#123; Logger.log(msg); &#125; &#125; catch (e) &#123;&#125;&#125;logWithNoInline(`...`); 结果，问题还是没有解决。这让我陷入了沉思。 第三轮排查：未绑定的断点就在我几乎要放弃的时候，我注意到了一个关键细节：当我想在 Logger.log(...) 这一行设置断点时，VS Code 显示这是一个 “未绑定断点” (Unbound breakpoint)。 这是一个决定性的线索！ “未绑定断点”意味着调试器在编译后的 JavaScript 文件中，找不到任何可以与这一行 TypeScript 代码对应的、可执行的代码。这强烈暗示，Logger.log(...) 这一行在编译打包后，被优化掉了！ 我立刻检查了 package.json 中的 package 脚本，它使用了 webpack --mode production。在生产模式下，Webpack 会启用 terser 进行代码压缩，而 terser 的默认行为之一就是移除 console.log 这样的“无副作用”代码。 我通过修改 webpack.config.js 来禁用这个优化： 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // ... optimization: &#123; minimizer: [ (compiler) =&gt; &#123; const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); new TerserPlugin(&#123; terserOptions: &#123; compress: &#123; drop_console: false, // 保留console.* &#125;, &#125;, &#125;).apply(compiler); &#125;, ], &#125;,&#125;; 并安装了 terser-webpack-plugin。我满怀信心地认为，问题已经解决了。 然而，现实再次给了我沉重一击：问题依然存在。 最终的测试：回归本源在排除了所有软件配置层面的可能性后，我不得不面对最后一个，也是最不愿意承认的猜测：这是一个更底层的，与我的开发环境本身有关的 Bug。 为了验证这一点，我进行了终极测试： 创建了一个纯粹的 test-debug.js 文件，模拟核心逻辑，不依赖任何项目配置。 使用 node --inspect-brk test-debug.js 命令，直接用 Node.js 的调试模式运行它。 在 VS Code 中附加到这个 Node.js 进程进行调试。 在这个最纯净的环境中，我得到了程序的最终输出： 12execute started with targetPath: undefinedNo target path provided 这个输出顺序无可辩驳地证明了：代码的实际执行顺序，自始至终都是正确的！ 结论：当调试器“说谎”时我们所有的努力，都是在试图修复一个实际上并不存在的“代码执行顺序”问题。真正的问题在于，VS Code 调试器在可视化渲染当前执行行时出错了。 它让我们“看到”了一个颠倒的执行顺序，但底层的 V8 引擎和 Node.js 依然在忠实地、正确地执行我们的代码。 经验教训 眼见不为实：不要 100% 相信调试器 UI 的高亮显示，尤其是在复杂的项目中（TypeScript + Webpack + Source Map）。 日志是你的终极真相：在怀疑执行顺序时，console.log 和日志点 (Logpoints) 是比单步调试更可靠的真相来源。查看“调试控制台”的输出，而不是代码编辑器的跳动。 隔离问题：当遇到无法解释的问题时，创建一个最小化的、纯净的复现环境，是剥离复杂配置、直达问题核心的有效手段。 关注最终结果：如果程序的最终行为是正确的，那么有时候我们可以接受调试器在可视化上的一些小瑕疵，继续前进。 这次离奇的经历提醒我，即使在今天高度发达的工具链中，我们依然需要保持批判性的思维，并通过多种方式交叉验证，才能找到问题的真正根源。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"问题排查","slug":"技术分享/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"VS Code","slug":"VS-Code","permalink":"https://ai.he0xwhale.xyz/tags/VS-Code/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ai.he0xwhale.xyz/tags/Debugging/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://ai.he0xwhale.xyz/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","permalink":"https://ai.he0xwhale.xyz/tags/Webpack/"},{"name":"Node.js","slug":"Node-js","permalink":"https://ai.he0xwhale.xyz/tags/Node-js/"}]},{"title":"解决 Gemini CLI 认证超时及日常使用问题","slug":"06/27/gemini_cli_auth_fix","date":"2025-06-27T02:55:16.000Z","updated":"2025-07-08T03:20:33.405Z","comments":true,"path":"2025/06/27/gemini_cli_auth_fix/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/27/gemini_cli_auth_fix/","excerpt":"","text":"你是否曾被命令行工具的认证超时问题困扰？当 Google Gemini CLI 尝试通过浏览器进行身份验证时，一个看似简单的步骤却可能隐藏着复杂的网络和配置挑战。本文将深入剖析我如何从一个棘手的认证超时问题入手，通过系统化的排查与调试，最终实现 Gemini CLI 的顺畅使用。这个过程不仅恢复了我的正常工作流程，更让我对现代命令行工具的认证机制、网络代理原理及问题诊断方法有了前所未有的深入理解。 问题初现: 浏览器回调请求挂起最初，当我依照 Gemini CLI 提供的指示，点击浏览器中的 “Sign in” 按钮后，浏览器会尝试重定向到一个本地的回调 URL，通常是 http://localhost:&lt;某个端口&gt;/oauth2callback?...。在我遇到的具体情况中，端口号最初显示为 33805，后来在 Wireshark 中捕获到的是 39065。然而，无论端口如何，这个关键的重定向请求在 Chrome 浏览器的 Network 标签页中一直显示为 pending 状态，而在 Firefox 中甚至没有任何网络活动记录（显示为空），这无疑是一个不祥之兆。最终，这种无响应导致了 Gemini CLI 在终端显示令人沮丧的错误信息：“Authentication timed out. Please try again.”（认证超时。请重试）。 为了初步诊断这一问题，我采取了一些基本的排查步骤: 浏览器无痕模式和不同浏览器测试: 考虑到浏览器缓存、扩展或插件可能引起的干扰，我特意在 Chrome 的无痕模式下以及使用 Firefox 浏览器进行了测试。这旨在排除因浏览器环境个性化设置或第三方插件导致的请求阻塞，然而不幸的是，问题依然顽固存在，没有得到缓解。 本地端口可达性检查: 我使用 telnet localhost &lt;端口号&gt; 命令来确认 Gemini CLI 预期监听的本地端口是否确实处于开放状态并可被访问。例如，我测试了 telnet localhost 34253 和 telnet localhost 33805。telnet 命令的成功连接表明，从操作系统层面看，该端口是开放的，并没有被其他应用程序明确占用或被防火墙完全阻止入站连接。 然而，尽管这些初步检查都显示正常，但仍未能直接揭示浏览器请求为何无法成功抵达本地服务器的深层原因。请求的 pending 状态暗示着它可能在网络栈的更早阶段就被卡住或放弃了，甚至没有真正发送出去。 Wireshark 诊断: 发现 HTTP 408 错误为了更深入地了解网络通信的底层细节，我决定启用专业的网络协议分析工具 Wireshark 进行抓包。我的目标是捕获 Loopback 接口上的所有相关流量，特别是目标端口为 33805（或后来观测到的 39065）的 TCP 数据包。 最初的抓包尝试，当我在 Loopback 接口上应用 tcp.port == 33805 的过滤条件时，出乎意料地没有发现任何数据包。这个结果让我一度重新怀疑，是否我的浏览器请求根本就没有从应用层成功发送到网络层，或者它在发送之前就被某些机制（例如浏览器内部的安全策略）给悄无声息地阻止了。 为了进一步排除这种可能性，并针对潜在的 HTTPS 到 HTTP 重定向阻止（即“混合内容”问题），我尝试了一个临时的、仅用于调试的措施: 在 Chrome 浏览器的 chrome://\\flags/#allow-insecure-downloads 选项中进行调整，尽管它主要与下载相关，但有时也可能影响其他类型的混合内容处理。 重新启动 Wireshark 抓包，并再次触发 Gemini CLI 的登录流程后，这次我终于捕获到了关键且决定性的网络通信信息: 成功发出的 HTTP GET 请求: Wireshark 记录到浏览器确实向 http://localhost:&lt;动态分配的端口，如39065&gt;/oauth2callback?... 发送了一个完整的 HTTP GET 请求，其中包含了 OAuth 认证所需的 state 和 code 参数。这里需要注意的是，由于本地回调服务器的端口通常是动态分配的，每次尝试都可能略有不同。Wireshark 的捕获证实了浏览器确实发出了请求，这彻底排除了浏览器未能发出请求的可能性，也澄清了之前关于混合内容阻止的疑虑—浏览器确实尝试了重定向。 服务器返回 HTTP/1.1 408 Request Timeout: 紧随浏览器请求之后，Wireshark 捕获到来自本地服务器的一个 HTTP 响应，其状态码是 408 Request Timeout。这是一个至关重要的信号！408 Request Timeout 意味着服务器端（在本例中，是 Gemini CLI 内部启动的用于接收 OAuth 回调的 Web 服务器）在等待客户端（浏览器）完成请求时发生了超时。然而，结合此情此景，它更常指示服务器在收到请求后，其内部处理流程未能按时完成。服务器在收到回调请求后，通常会立即向 Google 的 OAuth 2.0 令牌端点发起第二个服务器到服务器的请求，用从浏览器获取的 code 去交换实际的 access_token 和 refresh_token。如果这个内部的令牌交换过程因为某种原因耗时过长或失败，本地服务器就会因等待超时而向浏览器返回 408 错误。 随后的 TCP RST, ACK 包: 在 408 响应之后，还伴随着一个 TCP RST, ACK 包。RST（Reset）标志表示连接被突然终止。这通常发生在连接状态不匹配、协议错误，或者在收到 408 响应后，服务器决定立即关闭该连接，而不是等待正常的 TCP 关闭握手。这进一步印证了本地服务器在处理请求后遇到了某种无法继续的状况，并主动或被动地断开了与浏览器的连接。 这些抓包结果清晰地表明，问题不再是浏览器无法发送请求，而是 Gemini CLI 应用程序在接收到 OAuth 回调后，其内部处理逻辑未能成功完成，导致了超时。焦点现在完全转移到了 Gemini CLI 内部的网络通信和业务逻辑上。 定位根源: CLI 未走代理访问 Google API既然 Wireshark 已经确认本地服务器接收到了浏览器发来的 OAuth 回调请求，并且返回了 408 Request Timeout，那么最合理的推断是 Gemini CLI 在接收到 code 后，尝试向 Google OAuth 2.0 令牌端点（例如 oauth2.googleapis.com 或 www.googleapis.com）发送一个 服务器到服务器 的请求，用这个 code 去交换实际的 access_token 和 refresh_token。然而，由于我的网络环境访问 Google 相关服务必须通过代理，而 npx 运行的 Node.js 应用程序默认可能没有自动识别或使用我的系统代理设置，导致这个关键的出站请求未能成功抵达 Google 的服务器，从而在 CLI 内部引发了超时。 npx 是一个强大的工具，允许我们执行远程或本地的 Node.js 包可执行文件，而无需全局安装它们。当 npx 启动 gemini-cli 时，它实际上是下载了 Git 仓库，并在一个临时环境中运行其中的 Node.js 脚本。Node.js 应用程序通常会尝试读取标准的环境变量来配置其代理行为。如果这些环境变量没有被正确设置或应用程序没有被显式告知使用代理，它将尝试直接连接外部网络，这在需要代理的环境下必然会失败。 最终解决方案: 为了强制 Node.js 应用程序（即 Gemini CLI）在进行出站网络请求时使用代理，我在启动 Gemini CLI 之前，通过设置系统环境变量来配置代理信息。这些环境变量是 Node.js 及其许多 HTTP 客户端库默认会查找的: 123456789# Linux/macOS 用户在终端中执行export HTTP_PROXY=&quot;http://127.0.0.1:7890&quot; # 替换为你的 HTTP 代理地址和端口，例如：http://your.proxy.server:portexport HTTPS_PROXY=&quot;http://127.0.0.1:7890&quot; # 替换为你的 HTTPS 代理地址和端口，通常与 HTTP 代理相同export NO_PROXY=&quot;localhost,127.0.0.1&quot; # 关键：确保 localhost 请求不通过代理，避免内部回调也走代理导致问题# Windows 用户在命令提示符或 PowerShell 中执行set HTTP_PROXY=http://127.0.0.1:7890set HTTPS_PROXY=http://127.0.0.1:7890set NO_PROXY=localhost,127.0.0.1 深入理解 NO_PROXY 的双重重要性: NO_PROXY 环境变量在代理配置中扮演着关键角色，它明确指定了哪些目标地址的流量不应通过代理服务器转发。在此场景下，将其设置为 localhost,127.0.0.1 具有双重意义:首先，它确保了浏览器向本地 Gemini CLI 发送的 OAuth 回调请求能够直接抵达，而不会被错误地路由到外部代理，从而避免了“内卷”式的代理循环或不必要的网络延迟。其次，如果本地回调请求被强制通过代理，不仅效率低下，还可能因代理服务器不支持本地地址解析或安全策略限制而导致连接失败。因此，正确配置 NO_PROXY 是确保本地回调路径畅通无阻，并让 CLI 的出站请求能通过代理访问外部 Google API 的关键平衡点。确保 NO_PROXY 的值是逗号分隔的列表，且不包含空格，以保证其正确解析。 设置这些环境变量后，再次运行 npx https://github.com/google-gemini/gemini-cli，认证过程得以顺利完成！CLI 内部的 Node.js 进程现在能够通过指定的代理成功连接到 Google 的 OAuth 令牌端点，完成了令牌交换，从而解决了认证超时的问题。 日常使用优化: 全局安装 gemini 命令尽管 npx 提供了一种便捷的方式来运行远程的 Node.js 可执行文件，但其本质是为临时执行而设计的。每次使用 npx https://github.com/google-gemini/gemini-cli 时，它都会在你的系统临时目录中（例如 ~/.npm/_npx）下载或克隆 Git 仓库、安装依赖，并执行相应的命令。这意味着每次使用都需要一定的准备时间，而且最重要的是，当你关闭终端会话或 npx 进程完成后，它下载和安装的文件通常会被自动清理掉。因此，当你下一次尝试直接在终端中输入 gemini 命令时，系统会提示“没有该命令”，因为它已经不在你的系统 PATH 环境变量指向的任何目录中了。这对于需要频繁使用的 CLI 工具来说，显然不够方便。 为了实现 gemini 命令的便捷和持久化使用，使其能够像其他常规命令行工具一样，在任何时候、任何地方都能直接运行，我们需要将其进行全局安装。 我最初尝试通过 Git URL (npm install -g https://github.com/google-gemini/gemini-cli) 进行全局安装，但这遇到了几个错误: Git 仓库相关错误（fatal: 不是 git 仓库）和 Node.js 模块未找到错误（Cannot find package &#39;esbuild&#39;）。这些错误表明，npm 在从 Git URL 安装时，实际上会尝试在本地克隆的临时仓库中执行项目的构建脚本（例如 npm run bundle），而这些脚本可能依赖于完整的 Git 环境或特定的模块路径设置，这在 npm 的临时构建环境中可能无法满足，从而导致构建失败。 最终解决方案: 最可靠和推荐的方法是直接从 npm registry 全局安装预编译好的包。npm registry 存储的是已经打包和编译好的分发版本，这意味着 npm 不需要再在本地执行复杂的构建脚本，只需要下载并解压即可。 1npm install -g @google/gemini-cli npm install -g: 这是 Node.js 包管理器 npm 的命令，-g 标志表示进行全局安装，会将包的可执行文件放置到系统 PATH 环境变量所包含的目录中，使得 gemini 命令在任何位置都可直接调用。 @google/gemini-cli: 这是发布到 npm registry 的官方包名称，确保了下载的是稳定且经过测试的版本。 如果 npm 在下载包时也需要代理（因为 npm 自身的网络请求也可能受网络环境限制），你需要额外配置 npm 的代理设置，这会告知 npm 在其所有的网络请求中都使用指定的代理服务器: 123npm config set proxy http://127.0.0.1:7890npm config set https-proxy http://127.0.0.1:7890npm config set no-proxy localhost,127.0.0.1 npm config set 命令会将代理设置写入你的 npm 配置文件（通常是 ~/.npmrc），使其永久生效。 成功全局安装并配置好代理后，我就可以直接在任何终端会话中输入 gemini 命令来启动 Gemini CLI 了，并且它能够在我需要代理的网络环境下，顺畅地进行认证和后续操作。 通过这次全面的排查和学习，我不仅成功解决了 Gemini CLI 的认证超时顽疾，使其在我需要代理的网络环境下能够正常工作，还优化了 gemini 命令的日常使用体验。更重要的是，这个过程让我对复杂的网络通信（尤其是内外部代理）、CLI 工具的认证机制、Node.js 包管理的不同安装方式有了更深入、更实际的理解。这再次印证了在故障诊断中，逐步缩小范围、利用专业工具（如 Wireshark）并理解底层原理的重要性。现在，我可以顺畅且高效地进行云操作，也为未来遇到类似问题积累了宝贵的经验。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Gemini","slug":"技术分享/Gemini","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Gemini/"}],"tags":[{"name":"Gemini","slug":"Gemini","permalink":"https://ai.he0xwhale.xyz/tags/Gemini/"},{"name":"CLI","slug":"CLI","permalink":"https://ai.he0xwhale.xyz/tags/CLI/"},{"name":"认证","slug":"认证","permalink":"https://ai.he0xwhale.xyz/tags/%E8%AE%A4%E8%AF%81/"},{"name":"代理","slug":"代理","permalink":"https://ai.he0xwhale.xyz/tags/%E4%BB%A3%E7%90%86/"},{"name":"网络","slug":"网络","permalink":"https://ai.he0xwhale.xyz/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://ai.he0xwhale.xyz/tags/Troubleshooting/"}]},{"title":"Hexo 博客中 URL 路径出现重复日期的解决方案","slug":"06/24/hexo_permalink_fix","date":"2025-06-24T03:00:00.000Z","updated":"2025-07-08T03:16:04.535Z","comments":true,"path":"2025/06/24/hexo_permalink_fix/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/24/hexo_permalink_fix/","excerpt":"","text":"在使用 Hexo 搭建博客时，你可能会遇到如下问题： 文章的 URL 路径中出现了重复的日期字段，比如： 1http://localhost:4000/2025/06/24/2025/06/24/volantis_cyberpunk_style_avatar_bug/ 这通常是由于文章的物理路径与 Hexo 的默认 permalink 规则叠加造成的，本文将介绍如何避免 URL 中重复的日期路径。 🚩 问题复现示例假设文章的物理路径是： 1source/_posts/2025/06/24/volantis_cyberpunk_style_avatar_bug.md 同时 Front Matter 中包含： 1date: 2025-06-24 10:00:00 而 Hexo 默认的 permalink 配置是： 1permalink: :year/:month/:day/:title/ 此时构建出来的 URL 就会变成： 1/2025/06/24/2025/06/24/volantis_cyberpunk_style_avatar_bug/ ✅ 解决方案一：修改全局 permalink 配置 + 简化目录结构 打开 Hexo 根目录下的 _config.yml； 修改 permalink 设置： 1permalink: :year/:month/:day/:title/ 移动你的文章 .md 文件至 _posts/ 根目录： 1mv source/_posts/2025/06/24/volantis_cyberpunk_style_avatar_bug.md source/_posts/ 最终构建出来的 URL： 1/2025/06/24/volantis_cyberpunk_style_avatar_bug/ 如果你不想保留日期路径：将 _config.yml 中的 permalink 改为： 1permalink: :title/ 则构建 URL 为： 1/volantis_cyberpunk_style_avatar_bug/ ✅ 解决方案二：为单篇文章自定义 permalink如果你只想修改某篇文章的访问路径，可以在其 Front Matter 中手动设置： 1permalink: /2025/06/24/volantis_cyberpunk_style_avatar_bug/ 这样就不会受物理路径和全局 permalink 设置的影响，Hexo 将使用你指定的 URL。 ✅ 总结对比 方法 操作 适用范围 效果 修改 _config.yml 配置 + 整理 _posts 结构 修改 permalink 并搬移文章 全局生效 清晰、统一的 URL 路径 为单篇文章设置 permalink 修改文章 Front Matter 局部定制 灵活配置路径 希望本文能帮你清理掉 URL 中冗余的日期路径，保持博客结构清晰简洁。如果你想要我自动批量调整历史文章结构或生成脚本，请留言交流！","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"博客优化","slug":"博客优化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"}]},{"title":"Volantis 主题下自定义吉卜力风格与柔和配色的实践","slug":"06/20/volantis-jp-style-css","date":"2025-06-20T08:00:00.000Z","updated":"2025-07-08T03:16:35.263Z","comments":true,"path":"2025/06/20/volantis-jp-style-css/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/20/volantis-jp-style-css/","excerpt":"","text":"在搭建 Hexo 博客并使用 Volantis 主题的过程中，为了营造一种温柔、宁静、类似吉卜力风格的视觉效果，我进行了以下几个方面的样式调整和优化。 顶栏样式调整将默认主题的顶栏背景色替换为柔和的奶油色： 1234#l_header &#123; background-color: #e5ddc5 !important; box-shadow: none !important;&#125; 链接颜色调整为了呼应整体的暖色调，同时保持良好的可读性和视觉反馈，设置了如下链接颜色： 123456a &#123; color: #3b7d99;&#125;a:hover &#123; color: #bb4d3b;&#125; 模糊背景优化Volantis 默认通过 .blur 类结合 backdrop-filter 添加半透明白色背景。为了贴近吉卜力风格，我将其调整为更温暖的色调： 1234.blur &#123; background: rgba(250, 245, 235, 0.9) !important; /* 柔和奶油白 */ backdrop-filter: saturate(150%) blur(10px);&#125; 这可以让导航栏、顶部 cover 区域呈现柔光玻璃质感，更加温润不刺眼。 全局背景色设置为了让整个页面背景统一、温暖，采用柔和的奶油白作为主背景色，适用于页面主体、头部、底部等区域： 1234567body,.page,.header,.footer,.main &#123; background-color: #fff8e7 !important; /* 奶油白 */&#125; 背景色覆盖说明：问题定位与排查过程在设置 body 或 article 的背景色时，我遇到了一个问题：即使使用了 !important，设置的背景色依然无效，在 DevTools 中甚至会被划掉删除线。 排查过程如下： 初步怀疑被其他类覆盖，尝试提升选择器优先级，如 article.card，仍然无效。 观察 computed style 面板，发现真正生效的背景来自一个透明白的 rgba 值。 逐层审查 DOM，最终在 .blur 类上找到了这条规则： 123.blur &#123; background: rgba(255,255,255,0.9) !important;&#125; 这是 Volantis 主题为了实现玻璃拟态效果而添加的样式。 确认该规则在支持 backdrop-filter 的浏览器中通过 @supports 被启用，并且优先级极高。 尝试对 .blur 使用新的背景覆盖，测试不同透明度、颜色组合后，最终选用 rgba(250, 245, 235, 0.9) 作为主色。 同时，为防止 .blur 遮盖全局背景，设置 body, .page, .main 等关键容器背景色统一为奶油白。 通过上述设置，一个风格统一、色彩柔和、具有吉卜力美感的博客界面就完成了。 如果你也想打造自己的特色博客风格，不妨从配色入手，加入些微动效与模糊处理，会让整体观感更加细腻舒适。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"美化定制","slug":"博客之旅/美化定制","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E7%BE%8E%E5%8C%96%E5%AE%9A%E5%88%B6/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"CSS","slug":"CSS","permalink":"https://ai.he0xwhale.xyz/tags/CSS/"},{"name":"博客主题","slug":"博客主题","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"},{"name":"吉卜力","slug":"吉卜力","permalink":"https://ai.he0xwhale.xyz/tags/%E5%90%89%E5%8D%9C%E5%8A%9B/"}]},{"title":"Hexo 博客头像图片异常变回旧图的问题排查记录","slug":"06/20/hexo_avatar_bug","date":"2025-06-20T07:09:45.000Z","updated":"2025-07-08T03:16:28.279Z","comments":true,"path":"2025/06/20/hexo_avatar_bug/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/20/hexo_avatar_bug/","excerpt":"","text":"问题描述在使用 Hexo 搭建博客（主题为 Volantis）过程中，用户修改了博客头像路径： 1avatar: /images/website/avatar.png 原头像为旧图 /images/logo_2.png，已确认删除。但在使用 hexo server 启动后，首页初始加载时头像显示正常，一旦打开 Chrome DevTools 并刷新页面，头像却重新变回 /images/logo_2.png，尽管图片已被删除，且请求返回 404。 排查过程✅ 配置方面 清除 Hexo 缓存：hexo clean &amp;&amp; hexo g 删除 public/、.cache/、db.json 确认 themes/volantis/_config.yml 中 widgets.blogger.avatar 设置正确 确认模板文件 blogger.ejs 中渲染了正确路径 使用固定路径 &lt;img src=&quot;/images/website/avatar.png&quot; /&gt; 确保非变量问题 ✅ 运行时调试 使用 Firefox 正常，问题仅在 Chrome DevTools 下复现 DevTools 开启前头像正确，开启后刷新页面出现问题 尝试了 Break on → Attribute modifications，无效 控制台无 JS 报错，无 fallback 行为日志 document.querySelector(&#39;.avatar img&#39;).src 被动变为旧图 请求图片地址状态码为 404，但仍被请求 ✅ 判断结果此现象并非 Hexo 模板或输出问题，而是 Chrome DevTools 打开时触发了某种缓存&#x2F;快照机制，例如： Memory Cache Back&#x2F;Forward Cache（bfcache） 离线快照还原（某些版本 DevTools 有此行为） 这些机制会在刷新时“还原”旧 DOM 结构，或尝试访问旧图片路径，导致配置失效假象。 推荐的分析方法 grep 分析 Hexo 输出 HTML：确认没有旧图引用 curl 拉取页面源码，跳过浏览器行为确认 HTML 是否干净 使用 Puppeteer 加载页面，分析 DOM 实际渲染头像路径 使用 DevTools Performance 追踪是否有 JS 篡改 DOM 使用 MutationObserver 实时监控 img[src] 是否被改写 12345678910const avatarImg = document.querySelector(&#x27;.avatar img&#x27;);const observer = new MutationObserver(mutations =&gt; &#123; mutations.forEach(m =&gt; &#123; if (m.attributeName === &#x27;src&#x27;) &#123; console.warn(&#x27;[MutationObserver] src changed to:&#x27;, avatarImg.src); console.trace(); &#125; &#125;);&#125;);observer.observe(avatarImg, &#123; attributes: true &#125;); 最终选择由于问题可能来自浏览器的复杂缓存机制，短期内无法完全复现和修复，因此决定先不继续深究，保留此记录供未来参考。也欢迎大家留言共同讨论该问题 建议与避坑技巧 所有头像&#x2F;图片路径建议添加查询参数：?v=20250619 避免缓存 hexo clean &amp;&amp; rm -rf public/ 是每次改图后的标准操作 DevTools 开启时务必勾选 Disable cache widgets.index/page/mobile 均应显式设置 avatar","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"前端调试","slug":"前端调试","permalink":"https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"}]},{"title":"从 Hexo 模板创建新博客并独立管理 Volantis 子模块的完整过程","slug":"06/19/hexo_submodule_split_blog","date":"2025-06-19T06:52:18.000Z","updated":"2025-07-08T03:16:21.991Z","comments":true,"path":"2025/06/19/hexo_submodule_split_blog/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/19/hexo_submodule_split_blog/","excerpt":"","text":"在 Hexo 博客搭建中，很多用户会选择将主题如 Volantis 作为子模块管理以便于后续更新。然而，如果你想以现有的博客为模板创建新的博客，并保留主题改动，同时又不希望多个项目之间相互干扰，合理管理 Git 子模块就显得非常重要。 本文记录了一个完整的实践过程，包含遇到的问题、原因分析和最终的解决方法。 场景说明 已有博客项目：ai_blog，使用 fork 的 Volantis 主题作为 Git 子模块，且 _config.yml 中做了大量定制修改； 目标：创建一个新博客 tech_blog，以 ai_blog 为基础模板，但希望主题配置独立； 遇到的问题包括：子模块复用导致冲突、分支不同步、远程混乱、推送失败等。 一、从模板创建新项目12345678910111213# 克隆 ai_blog，包括子模块git clone --recursive https://github.com/yourname/ai_blog.git tech_blogcd tech_blog# 删除旧 git 记录，准备建立新仓库rm -rf .gitgit init# 重新添加远程并提交git remote add origin https://github.com/yourname/tech_blog.gitgit add .git commit -m &quot;初始化 tech_blog&quot;git push -u origin main 二、Volantis 主题子模块独立化原问题多个项目共享同一个 fork 的主题仓库，如果任意一个项目修改了 _config.yml 并 push，会影响其他项目。 解决方案：为新博客单独创建 volantis-tech 仓库 首先在github上创建新的空白仓库：volantis-tech 再执行下面的命令 123456789101112131415# 克隆 volantis 源仓库 git clone --bare https://github.com/yourname/volantis.git volantis-bare cd volantis-bare# 推送为新仓库 git push --mirror https://github.com/yourname/volantis-tech.git# 清理 cd .. rm -rf volantis-bare 12345678910111213141516---## 三、彻底移除旧子模块并添加新主题```bash# 移除旧子模块引用git submodule deinit -f themes/volantisgit rm -f themes/volantisrm -rf .git/modules/themes/volantisrm -rf themes/volantisrm -f .gitmodules# 添加新的 volantis-tech 作为子模块git submodule add https://github.com/yourname/volantis-tech.git themes/volantisgit submodule update --init --recursive 四、关于 _config.yml 修改后未生效的问题 修改了 themes/volantis/_config.yml，但 GitHub 页面没有变化？ 这是因为 Volantis 是子模块，其更改需要进入子模块内部手动提交和推送： 12345cd themes/volantisgit checkout -b custom-fontawesomegit add _config.ymlgit commit -m &quot;修改配置&quot;git push --set-upstream origin custom-fontawesome 然后回到主项目： 1234cd ../..git add themes/volantisgit commit -m &quot;更新子模块引用&quot;git push 五、解决 git push 报错问题例如： 1fatal: 当前分支 main 没有对应的上游分支。 解决方式： 1git push --set-upstream origin main 六、其他注意事项 .git/modules/ 是 Git 存放子模块缓存数据的地方，必须清除干净； 使用多个项目共用子模块时，应考虑使用不同分支，或完全复制主题； 如果不能再 fork 自己的仓库，可以用 git clone --bare + git push --mirror 方案手动创建副本。 总结通过本次实践，我们完整演示了如何从已有 Hexo 项目中派生一个新项目，并妥善管理子模块以避免多个项目间的冲突。推荐在多个博客中使用 fork + 分支方式隔离配置，确保互不干扰。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"Git","slug":"Git","permalink":"https://ai.he0xwhale.xyz/tags/Git/"},{"name":"Git Submodule","slug":"Git-Submodule","permalink":"https://ai.he0xwhale.xyz/tags/Git-Submodule/"}]},{"title":"Hexo 博客中添加字数统计功能出现标题解析异常的排查记录","slug":"06/18/hexo-wordcount-bugfix","date":"2025-06-18T03:10:00.000Z","updated":"2025-07-08T03:16:49.174Z","comments":true,"path":"2025/06/18/hexo-wordcount-bugfix/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/18/hexo-wordcount-bugfix/","excerpt":"","text":"在为 Hexo 博客集成字数统计功能时，我遇到一个渲染异常的问题：一段普通的文字和其后的图片被误解析为标题（&lt;h2&gt; 标签），导致显示错乱。这篇文章记录了该问题的排查和解决过程，供遇到类似情况的朋友参考。 一、背景与问题描述我为 Hexo 博客安装了 hexo-wordcount 插件，并使用 Volantis 主题。在配置 top_meta 后，字数统计功能成功显示。但在文章中记录成功效果时，出现如下异常渲染： 1234&lt;h2 id=&quot;最终，在文章标题下方正确显示了字数统计和阅读时长信息。&quot;&gt; ... &lt;img src=&quot;...&quot;&gt;&lt;/h2&gt; 原因是如下 Markdown 被错误渲染为一个标题标签： 12最终，在文章标题下方正确显示了字数统计和阅读时长信息。![wordcount](../../../../images/screenshot/2025-06-13_11-18_wordcount.png) 二、原因分析这一问题的根本原因在于 Markdown 渲染器（如 hexo-renderer-marked 或 markdown-it）在处理文字段落紧跟图片的语法时，某些情况下可能会将其视为同一个段落，并错误地转换为标题。 特别是在前一行末尾为句号或中文符号，下一行又是图片语法（![...](...)），更容易被误判。 三、解决办法✅ 方法一：添加空行最简单直接的方式是在文字和图片之间添加空行： 123最终，在文章标题下方正确显示了字数统计和阅读时长信息。![wordcount](../../../../images/screenshot/2025-06-13_11-18_wordcount.png) 这样就能明确告诉 Markdown 渲染器，两者为独立段落，避免误合并。 ✅ 方法二：使用 HTML 显式结构如果你希望行为更可控，也可以使用 HTML 标签来书写： 12&lt;p&gt;最终，在文章标题下方正确显示了字数统计和阅读时长信息。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/screenshot/2025-06-13_11-18_wordcount.png&quot; alt=&quot;wordcount&quot;&gt;&lt;/p&gt; 适用于结构化或需要稳定渲染效果的写作场景。 四、推荐做法如果你经常写文章涉及图片展示，建议： 保持图片前后有空行，避免粘连； 为每段落标题单独一行，加空行隔开； 避免中文段落结尾紧贴 Markdown 图片语法； 也可视情况用 HTML 标签规避解析器差异。 五、总结Markdown 的“简洁”语法有时也容易出现歧义。在 Hexo + Volantis 环境中，特别是涉及插件渲染和主题模板的场景，更需要小心结构布局。希望本文对你遇到类似问题时有所帮助。 如果你在 Hexo 使用过程中也遇到其他类似问题，欢迎留言交流 🙌。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ai.he0xwhale.xyz/tags/Markdown/"},{"name":"Bug排查","slug":"Bug排查","permalink":"https://ai.he0xwhale.xyz/tags/Bug%E6%8E%92%E6%9F%A5/"}]},{"title":"用 Cursor 开发 VSCode 插件时遇到的版本兼容性问题排查实录","slug":"06/17/vscode-cursor-plugin-issue","date":"2025-06-17T06:13:00.000Z","updated":"2025-06-17T06:13:00.000Z","comments":true,"path":"2025/06/17/vscode-cursor-plugin-issue/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/17/vscode-cursor-plugin-issue/","excerpt":"","text":"VSCode 插件在 Cursor 不能用？一次环境兼容性大坑的排查与解决最近在开发 VSCode 插件时，遇到了一个非常隐蔽但又很有代表性的大坑：插件在官方 VSCode 客户端中一切正常，但在 Cursor 编辑器中死活激活不了，命令也不显示。 这篇文章记录我的排查过程、最终的解决办法，以及一些经验教训，希望能帮到遇到类似问题的你。 问题描述我写了一个 VSCode 插件，在官方 VSCode 客户端里可以正常激活和使用，命令也能正常显示。但当我切换到 Cursor 编辑器，发现插件根本没有被激活，命令也找不到。 我反复检查代码、配置，依赖也都装了，编译也没报错，就是不行！ 排查过程1. 常规排查 重新安装依赖（pnpm install） 重新编译（pnpm run compile） 检查 package.json 配置 查看输出面板和调试控制台 结果都没有发现明显问题。 2. 环境对比（真实心路）其实在排查过程中，我并没有第一时间注意到 VSCode 和 Cursor 的底层版本差异。一开始只是觉得它们界面很像，理所当然地以为插件兼容性不会有大问题。 直到我在向 ChatGPT 提问、查找资料时，AI 给出的参考链接里，有一位开发者在论坛帖子中提到了 Cursor 的 VSCode 版本和 package.json 里声明的版本不一致，我才恍然大悟！ 3. 灵感来源这个帖子真的救了我一命：How to debug a VS Code extension using CursorAI 他们的解决办法是：把 package.json 里的 vscode 版本降级到 Cursor 支持的版本，比如 ^1.93.0，然后重新装依赖、重新编译，插件就能用了！ 解决办法 修改 package.json： 12345&#123; &quot;engines&quot;: &#123; &quot;vscode&quot;: &quot;^1.93.0&quot; &#125;&#125; 同步修改 @types/vscode 依赖版本为 ^1.93.0 重新安装依赖： 1pnpm install 重新编译： 1pnpm run compile 重启 Cursor，插件终于能正常激活了！ 经验与建议 环境兼容性问题很隐蔽，尤其是 VSCode 插件开发，别只盯着代码，环境和依赖版本也很关键！ 遇到问题多去官方论坛、社区搜一搜，有时候一句话就能救你一天。 提问时尽量描述清楚环境差异和具体表现，这样更容易获得有用的答案。 很多时候，我们并不是靠自己一步步推理出来的，而是通过社区、AI、搜索引擎等外部信息，才发现了问题的本质。 参考链接 How to debug a VS Code extension using CursorAI 如果你也遇到类似问题，欢迎在评论区留言交流！ 希望这篇文章能帮你少走弯路！ 如需进一步交流，欢迎关注我的频道&#x2F;博客，后续会持续分享更多开发实战经验！","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"开发实战","slug":"技术分享/开发实战","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://ai.he0xwhale.xyz/tags/VSCode/"},{"name":"Cursor","slug":"Cursor","permalink":"https://ai.he0xwhale.xyz/tags/Cursor/"},{"name":"插件开发","slug":"插件开发","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo 博客结构化数据与 SEO 配置实践全记录","slug":"06/17/hexo_seo_debug_guide","date":"2025-06-17T02:43:01.000Z","updated":"2025-07-08T03:17:05.774Z","comments":true,"path":"2025/06/17/hexo_seo_debug_guide/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/17/hexo_seo_debug_guide/","excerpt":"","text":"最近对 Hexo 博客进行了结构化数据（Structured Data）与 SEO 配置优化，过程中踩了不少坑，以下是完整的记录与总结，希望对同样使用 Hexo 的朋友有所帮助。 一、起因：Search Console 无法检测结构化数据起初在 Google 的 Rich Results 测试工具和 Search Console 中发现博客页面无法识别任何结构化数据，怀疑是结构化数据输出有误。 二、排查过程与问题定位1. 替换 schema.org.cn 为 schema.org在检查页面源代码后发现结构化数据的 @context 字段中使用了 https://schema.org.cn，而 Google 仅识别 https://schema.org，于是批量替换： 1find . -type f -exec sed -i &#x27;s/schema\\.org\\.cn/schema.org/g&#x27; &#123;&#125; + 修改后重新部署，Rich Results 测试开始可以正常识别结构化数据。但具体是因为该原因还是只是延迟导致的，还没有完全确定。 2. Search Console 仍无索引虽然 Rich Results 工具成功检测，但 Search Console 中依然没有任何结构化数据结果。考虑可能是 Google 尚未重新抓取，决定暂时不再深究。 三、SEO 配置优化建议（基础 + Open Graph + Structured Data）（1）基础 SEO 设置keywords 配置1use_tags_as_keywords: true 建议在首页或重要页面额外加上 front-matter 中的 keywords 字段，并限制关键词数量（推荐 5–10 个）以避免关键词堆砌。 description 描述1use_excerpt_as_description: true 摘要需控制在 150–160 字，建议重要页面手动设置 description，可加入品牌词、核心亮点。 robots 设置12345home_first_page: index,followhome_other_pages: noindex,followarchive: noindex,followcategory: noindex,followtag: noindex,follow 若分页&#x2F;分类&#x2F;标签页确实有价值内容，可将其调整为 index,follow。 sitemap.xml 配置确保安装并正确配置： 1npm install hexo-generator-sitemap --save 并在 robots.txt 中声明： 1Sitemap: https://your-domain.com/sitemap.xml canonical 链接建议启用，避免重复页面影响权重。 （2）Open Graph 社交分享默认图片open_graph.image 建议使用完整 URL，例如： 12open_graph: image: https://cdn.jsdelivr.net/gh/your-repo/img/android-chrome-192x192.png Twitter 类型如果文章有大封面图，建议使用： 1twitter_card_type: summary_large_image Twitter ID12twitter_id: &quot;@your_id&quot;twitter_site: &quot;@your_site&quot; （3）Structured Data 结构化数据已启用类型：BlogPosting、BreadcrumbList、Organization、Person、Website。 建议确认以下字段输出完整： headline datePublished dateModified mainEntityOfPage author.name publisher.logo 组织信息 Organization12345678structured_data: data: organization: name: &quot;Your Brand&quot; url: &quot;https://your-domain.com&quot; sameAs: - &quot;https://twitter.com/your_brand&quot; - &quot;https://github.com/your_brand&quot; 作者信息 Person1234person: name: &quot;Your Name&quot; url: &quot;https://your-domain.com/about&quot; image: &quot;https://your-domain.com/img/avatar.png&quot; 四、Search Console 报错 sitemap.xml “Couldn’t fetch” 的解决在 Search Console 添加 sitemap.xml 时出现 “Couldn’t fetch” 报错，但直接访问如 https://ai.example.xyz/sitemap.xml 却正常。 排查后确认是插件未安装导致未生成 sitemap 文件。解决方法： 1npm install hexo-generator-sitemap --save 然后重新部署： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 再次提交 sitemap 即可正常解析。 五、总结通过上述一系列配置与排查，博客的结构化数据已能被 Google 正确识别，同时也梳理了 SEO 的相关策略，包括关键词、摘要、社交分享优化等。 建议所有 Hexo 用户结合自己内容情况进行适度调整，重点关注 sitemap 输出、结构化数据 schema 正确性、以及 Meta 标签内容丰富性。 祝各位博客 SEO 提升顺利！","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"优化推广","slug":"博客之旅/优化推广","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E4%BC%98%E5%8C%96%E6%8E%A8%E5%B9%BF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"SEO","slug":"SEO","permalink":"https://ai.he0xwhale.xyz/tags/SEO/"},{"name":"OpenGraph","slug":"OpenGraph","permalink":"https://ai.he0xwhale.xyz/tags/OpenGraph/"},{"name":"结构化数据","slug":"结构化数据","permalink":"https://ai.he0xwhale.xyz/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/"},{"name":"搜索引擎优化","slug":"搜索引擎优化","permalink":"https://ai.he0xwhale.xyz/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"}]},{"title":"Hexo 博客中添加字数统计功能的实践记录","slug":"06/13/hexo-wordcount-practice","date":"2025-06-13T02:49:18.000Z","updated":"2025-07-08T03:17:35.006Z","comments":true,"path":"2025/06/13/hexo-wordcount-practice/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/13/hexo-wordcount-practice/","excerpt":"","text":"在搭建 Hexo 博客并使用 Volantis 主题时，我尝试为文章添加字数统计功能。以下是我在此过程中遇到的问题和最终解决方案的完整记录。 一、安装插件与初始配置我按照_config.yml中说明的，安装了 hexo-wordcount 插件： 1npm i hexo-wordcount 并在博客volantis主题目录下的 _config.yml 文件中进行了如下配置： 1234plugin: # ...(省略) wordcount: enable: true 并运行以下命令以重建博客： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 二、发现没有生效尽管配置无误，且 hexo-wordcount 插件安装成功，但在本地启动博客预览时，文章标题下方并未显示任何字数统计信息。 三、逐步排查1. 检查 article.ejs首先我查看了主题路径下的 themes/volantis/layout/_partial/article.ejs，发现其通过 &lt;%- partial(&#39;meta&#39;, &#123;post: post, position: &#39;top&#39;&#125;) %&gt; 引用了 meta.ejs 文件，即所有顶栏信息都来源于该处。 2. 查看 meta.ejs继续跟踪到 themes/volantis/layout/_partial/meta.ejs，该文件通过如下逻辑决定顶部信息的内容： 12345&lt;% getList(topMetas).forEach(function(meta) &#123; %&gt; &lt;% if (meta in theme.article.body.meta_library)&#123; %&gt; &lt;%- partial(&#x27;../_meta/&#x27; + meta, &#123;post: post&#125;) %&gt; &lt;% &#125; %&gt;&lt;% &#125;) %&gt; 说明真正负责渲染字数统计的代码位于 themes/volantis/layout/_meta/wordcount.ejs 文件。 3. 找到字数统计渲染模板我找到了该文件，其内容如下： 1234567891011121314&lt;% if (theme.plugins.wordcount.enable) &#123; %&gt; &lt;div class=&quot;new-meta-item wordcount&quot;&gt; &lt;a class=&#x27;notlink&#x27;&gt; &lt;i class=&quot;&lt;%- theme.article.body.meta_library.wordcount.icon_wordcount %&gt; fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;p&gt;&lt;%- __(&#x27;post.wordcount&#x27;, wordcount(post.content))%&gt;&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;new-meta-item readtime&quot;&gt; &lt;a class=&#x27;notlink&#x27;&gt; &lt;i class=&quot;&lt;%- theme.article.body.meta_library.wordcount.icon_duration %&gt; fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;p&gt;&lt;%- __(&#x27;post.duration&#x27;, min2read(post.content))%&gt;&lt;/p&gt; &lt;/a&gt; &lt;/div&gt;&lt;% &#125; %&gt; 模板存在，配置也没报错，为什么就是不显示呢？ 四、真正的原因查看和AI的对话，我注意到了top_meta这个配置项，最终我意识到问题出在一个不起眼的配置项： 1234theme: article: body: top_meta: [author, category, date, wordcount, counter] 在我的原始配置中，并未在 top_meta 中包含 wordcount，所以尽管一切准备就绪，模板中没有调用它，自然就不会渲染出来。 五、成功显示添加了 wordcount 到 top_meta 列表后，再次运行： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 最终，在文章标题下方正确显示了字数统计和阅读时长信息： 至此，字数统计功能成功集成。如果你也遇到类似问题，可以从以下几点排查： 插件是否正确安装 _config.yml 中是否启用了 wordcount top_meta 中是否包含 wordcount 模板文件是否存在 wordcount.ejs 希望这篇文章能帮到你。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"字数统计","slug":"字数统计","permalink":"https://ai.he0xwhale.xyz/tags/%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/"}]},{"title":"Hexo 博客中为文章添加封面图的实践记录","slug":"06/12/hexo-cover-image-practice","date":"2025-06-12T07:00:00.000Z","updated":"2025-07-08T03:16:13.387Z","comments":true,"path":"2025/06/12/hexo-cover-image-practice/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/12/hexo-cover-image-practice/","excerpt":"","text":"1. 写在前面在搭建 Hexo 博客的过程中，我一直希望文章列表能更美观一些。特别是首页的文章卡片，如果能加上一张封面图，整体效果会更加吸引人。于是我着手尝试为文章添加封面图，并记录下这个过程，希望对同样使用 Volantis 主题的朋友有所帮助。 2. 封面图功能的支持背景我使用的是 Hexo + Volantis 主题，发现主题的文章预览卡片中，实际上是支持封面图显示的。只是这一功能并不默认开启，也没有在文档中有明显说明，需要我们自己手动配置。 在文章的 front-matter 中加入headimg字段，就可以控制每篇文章的封面图显示。 3. 添加封面图的方法在每篇 Markdown 文章的开头（也就是 front-matter 区域），添加 headimg 字段即可。 比如： 1234567---title: Hexo 博客封面图测试date: 2025-06-10 16:20:00tags: - 博客测试cover: /images/test-cover.jpg--- 💡 图片路径推荐放在 source/images/ 目录中，发布后可通过 /images/xxx.jpg 的形式引用。 4. 封面图排查与验证过程一开始，我在文章中添加了 cover 字段，却没有显示封面图。于是我开始了排查过程： 4.1 从 layout 开始追查我打开了主题中的 layout/index.ejs 文件，发现它引用了 _partial/archive 模板： 1&lt;%- partial(&#x27;_partial/archive&#x27;) %&gt; 4.2 查看 _partial&#x2F;archive.ejs在 archive.ejs 中，每一篇文章都通过如下方式渲染： 1&lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt; 4.3 最终定位到 post.ejs在 post.ejs 中，我看到了如下片段： 123&lt;% if (post.headimg) &#123; %&gt; &lt;img src=&quot;&lt;%- post.headimg %&gt;&quot; ... /&gt;&lt;% &#125; %&gt; 这时候我才意识到，原来 Volantis 主题是通过 headimg 字段来识别封面图的。 于是我把 front-matter 中的 cover 改成了 headimg，问题就解决了！ 5. 最终效果与小结现在，我的博客首页已经成功地为每篇文章展示封面图了。效果如下： 图片大小自动适配卡片宽度 支持本地图片引用（推荐放到 source/images/ 目录） 不需要修改任何模板，只需配置 headimg 字段即可 5.1 使用建议 每篇文章的封面图尽量统一尺寸，保持视觉一致性 可以使用 Gork、Canva 等工具快速生成封面图 如果有自动化需求，也可以结合脚本为旧文章批量添加封面字段 希望这篇记录对你有所帮助！","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"博客封面图","slug":"博客封面图","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2%E5%9B%BE/"},{"name":"实践记录","slug":"实践记录","permalink":"https://ai.he0xwhale.xyz/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo 博客中插入本地图片的实践记录","slug":"06/11/markdown_add_image","date":"2025-06-11T09:00:00.000Z","updated":"2025-07-08T03:17:21.326Z","comments":true,"path":"2025/06/11/markdown_add_image/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/11/markdown_add_image/","excerpt":"","text":"🗃️ 图片存放位置的选择我将图片统一放在了博客项目的 source/images/ 目录下，这样在 Hexo 构建时会自动复制到 public/images/ 中，路径清晰、引用方便。 ✏️ Markdown 插图语法示例在 Markdown 中插入图片，我采用的是标准语法： 1![评论区截图](/images/comment-preview.png) 图片路径是以 /images/ 开头的绝对路径，对应的是构建后 public/images/ 中的资源。 🔍 本地预览验证方法执行以下命令后，可以本地预览： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 浏览器打开 http://localhost:4000/ 后，文章内图片能正常显示。也可以直接访问图片链接： 1http://localhost:4000/images/comment-preview.png 如果图片能单独访问，但在文章里不显示，那就要检查是否用了相对路径、或者图片链接是否打错。 ✅ 总结Hexo 插图其实不复杂，只要把图片放在 source/ 下，并使用正确路径，就可以稳定地显示。以后写文时，我都会统一放在 source/images/，省心不少。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ai.he0xwhale.xyz/tags/Markdown/"},{"name":"插图","slug":"插图","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8F%92%E5%9B%BE/"},{"name":"博客技巧","slug":"博客技巧","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/"}]},{"title":"Hexo 博客中添加分类、标签、关于、友链页面的完整教程（Volantis 主题）","slug":"06/11/hexo-volantis-add-pages-guide","date":"2025-06-11T04:00:00.000Z","updated":"2025-07-08T03:17:12.922Z","comments":true,"path":"2025/06/11/hexo-volantis-add-pages-guide/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/11/hexo-volantis-add-pages-guide/","excerpt":"","text":"Hexo Volantis 添加常用页面指南前言在搭建 Hexo 博客并使用 Volantis 主题时，很多人会遇到访问 /categories/、/tags/、/about/ 或 /friends/ 页面时提示 Cannot GET 的问题。本文将手把手教你如何手动添加这些页面并正确配置它们的 front-matter，从而让博客结构更完整，功能更齐全。 一、添加分类页面（&#x2F;categories&#x2F;）1. 安装插件（如未安装）1npm install hexo-generator-category --save 2. 创建页面1hexo new page categories 3. 修改 front-matter编辑 source/categories/index.md 内容如下： 12345---layout: categoryindex: truetitle: 分类--- 4. 重建博客1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 5. 访问验证浏览器访问：http://localhost:4000/categories/ 二、添加标签页面（&#x2F;tags&#x2F;）1. 创建页面1hexo new page tags 2. 修改 front-matter编辑 source/tags/index.md 内容如下： 12345---layout: tagindex: truetitle: 标签--- 3. 重新生成并访问1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 访问：http://localhost:4000/tags/ 三、添加关于页面（&#x2F;about&#x2F;）1. 创建页面1hexo new page about 2. 编辑 front-matter 和正文123456---title: 关于我layout: page---你好，我是 XXX。欢迎来到我的博客。 3. 访问验证浏览器访问：http://localhost:4000/about/ 四、添加友链页面（&#x2F;friends&#x2F;）1. 创建页面1hexo new page friends 2. 编辑 front-matter 和内容123456789101112---title: 友链layout: pagecomments: false---欢迎交换友链，请留言或联系我。## 友情链接- [Hexo 官方文档](https://hexo.io/)- [Volantis 主题文档](https://volantis.js.org/) 3. 可选：使用卡片式展示Volantis 支持自定义 friends.yml 数据文件，可配合自定义模板实现卡片式展示。 五、常见问题与总结页面生成了但访问仍然报错？请检查： source/xxx/index.md 文件是否存在 front-matter 是否写错字段（必须包含 layout: xxx 和 index: true） 是否执行了 hexo clean &amp;&amp; hexo g Volantis 支持的 layout 对照表： 页面类型 layout 值 分类页 category 标签页 tag 关于页 page 友链页 page 附录：页面文件结构参考123456789source/├── about/│ └── index.md├── categories/│ └── index.md├── tags/│ └── index.md├── friends/│ └── index.md 生成后的页面会在 public/ 目录中对应生成。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"博客页面","slug":"博客页面","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/"},{"name":"分类标签","slug":"分类标签","permalink":"https://ai.he0xwhale.xyz/tags/%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE/"},{"name":"友链页面","slug":"友链页面","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2/"}]},{"title":"Hexo 博客中集成 Giscus 评论系统的实践记录","slug":"06/10/hexo_giscus_setup","date":"2025-06-10T10:00:00.000Z","updated":"2025-07-08T03:15:49.895Z","comments":true,"path":"2025/06/10/hexo_giscus_setup/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/10/hexo_giscus_setup/","excerpt":"","text":"Hexo 集成 Giscus 评论系统完整指南📘 一、Giscus 简介Giscus 是一个基于 GitHub Discussions 的现代评论系统，支持 Markdown、暗黑模式、Reactions，并通过 GitHub OAuth 实现身份识别。它不需要额外数据库，适用于技术博客、文档站点等。 volantis默认支持 Giscus，所以选择了这个插件系统。 🚀 二、准备工作2.1 拥有一个公开 GitHub 仓库确保你的博客源代码所在的仓库是公开的。 2.2 Hexo 安装与主题准备本文以 Volantis 主题为例，你应已完成以下操作： 安装 Hexo 配置并使用 Volantis 主题 启用 Hexo 的 deploy 功能（如 hexo-deployer-git） 🔧 三、GitHub 端配置3.1 启用 Discussions 功能 进入你的 GitHub 仓库主页 点击菜单栏的【Settings】→ 左侧【Features】 → 勾选 Discussions 3.2 创建 Discussion 分类 打开仓库的 Discussions 页面 点击右上角 ⚙️ Settings 创建一个新分类，建议类型为 Announcements 复制该分类的名称（如 General）和 ID（通过 giscus.app 获取） 3.3 安装 Giscus GitHub App 打开 https://github.com/apps/giscus 点击【Install】 选择你博客所用的仓库进行授权 ⚙️ 四、使用 Giscus 配置生成器访问 https://giscus.app 进行配置： Repository：填写 yourname/yourrepo Category：选择刚才创建的分类 Mapping：选择 pathname（推荐） Input position：选择 Top Theme：light 或 preferred_color_scheme Language：选择 zh-CN 建议启用的特性 ✅ Enable reactions for the main post ✅ Load the comments lazily ❌ Emit discussion metadata（一般不必） ✅ Place the comment box above the comments 点击底部【Copy code】，复制生成的配置 JSON 内容。 🛠️ 五、Hexo 中集成 Giscus（Volantis 主题）5.1 配置主题文件编辑文件： 1themes/volantis/layout/_plugins/comments/giscus/script.ejs 确认已有以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; volantis.layoutHelper(&quot;comments&quot;,`&lt;div id=&quot;giscus_container&quot;&gt;&lt;/div&gt;`) volantis.giscus = &#123;&#125;; function check_giscus() &#123; if (volantis.dark.mode === &quot;dark&quot;) &#123; volantis.giscus.Theme = &#x27;&lt;%- theme.comments.giscus.theme.dark %&gt;&#x27;; &#125; else &#123; volantis.giscus.Theme = &#x27;&lt;%- theme.comments.giscus.theme.light %&gt;&#x27;; &#125; return document.getElementById(&quot;giscus_container&quot;); &#125; function p_giscus() &#123; const HEAD = check_giscus(); if (!HEAD) return; let cfg = Object.assign(&lt;%- JSON.stringify(theme.comments.giscus) %&gt;,pdata.commentConfig) const script = document.createElement(&#x27;script&#x27;); script.setAttribute(&#x27;src&#x27;, &#x27;https://giscus.app/client.js&#x27;); Object.keys(cfg).forEach(k=&gt;&#123; if (k != &quot;theme&quot;) &#123; script.setAttribute(&#x27;data-&#x27;+k, cfg[k]); &#125; &#125;) script.setAttribute(&#x27;data-theme&#x27;, volantis.giscus.Theme); script.setAttribute(&#x27;crossorigin&#x27;, &quot;anonymous&quot;); HEAD.appendChild(script); &#125; function dark_giscus() &#123; const HEAD = check_giscus(); if (!HEAD) return; const message = &#123; setConfig: &#123; theme: volantis.giscus.Theme &#125; &#125;; const giscusIframe = document.querySelector(&#x27;iframe.giscus-frame&#x27;); giscusIframe.contentWindow.postMessage(&#123; giscus: message &#125;, &#x27;https://giscus.app&#x27;); &#125; p_giscus(); volantis.dark.push(dark_giscus);&lt;/script&gt; 5.2 主题配置文件 _config.yml (theme目录下的)12345678910111213141516comments: giscus: repo: yourname/yourrepo repo-id: YOUR_REPO_ID category: General category-id: YOUR_CATEGORY_ID mapping: pathname strict: 0 reactions-enabled: 1 emit-metadata: 0 input-position: top theme: light: light dark: dark_dimmed lang: zh-CN loading: lazy 🧪 六、本地调试与错误排查在调试过程中，我遇到了一些比较典型的问题，这里记录下来以供参考。 6.1 常见问题 An error occurred: giscus is not installed on this repository 一开始我没注意到要安装 Giscus 的 GitHub App，导致一直报这个错。后来在 https://github.com/apps/giscus 页面安装之后问题解决了。 403 Forbidden: repo&#x3D;undefined 这个问题出现在我忘记正确填写主题配置文件中的 repo 和 repo-id。另外要注意，相关配置必须写在 themes/volantis/_config.yml 中，而不是_config.volantis.yml文件。 📤 七、部署与 Git 提交使用以下 deploy.sh 自动部署脚本： 1234567891011121314151617181920212223#!/bin/bashset -eecho &quot;🧹 Cleaning cache and public folder...&quot;hexo cleanecho &quot;📦 Generating static files...&quot;hexo generateecho &quot;🚀 Deploying to GitHub Pages...&quot;hexo deployecho &quot;✅ Hexo deploy finished.&quot;# 提交 source 源码（包含主题子模块）echo &quot;📁 Committing source code...&quot;git submodule foreach &#x27;git add . &amp;&amp; git commit -m &quot;update submodule&quot; || echo &quot;No changes in submodule&quot;&#x27;git add .read -p &quot;📝 Enter commit message: &quot; msggit commit -m &quot;$msg&quot;git push origin mainecho &quot;🎉 All done!&quot; ✅ 八、效果预览与总结在部署完成后，我访问了博客页面，Giscus 评论区成功加载。它的加载速度很快，界面简洁，支持登录用户互动，还能显示 emoji reactions。 这次集成体验整体比较顺利，唯一花时间的是理清配置的几个关键点。整体来看，Giscus 的无后端、无广告、与 GitHub 无缝集成等特点，非常契合我的博客需求。如果你也在使用 Hexo 搭建博客，不妨也试试 Giscus —— 搭起来其实没那么难。","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"评论系统","slug":"评论系统","permalink":"https://ai.he0xwhale.xyz/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Giscus","slug":"Giscus","permalink":"https://ai.he0xwhale.xyz/tags/Giscus/"},{"name":"GitHub Discussions","slug":"GitHub-Discussions","permalink":"https://ai.he0xwhale.xyz/tags/GitHub-Discussions/"}],"author":"he0xwhale"},{"title":"Hexo 博客中 Markdown 标题序号的添加与规范实践","slug":"06/10/hexo_markdown_title_numbering","date":"2025-06-10T09:00:00.000Z","updated":"2025-07-08T03:15:57.475Z","comments":true,"path":"2025/06/10/hexo_markdown_title_numbering/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/10/hexo_markdown_title_numbering/","excerpt":"","text":"引言在写博客时，Markdown 标题序号经常会出现缺失或混乱的问题，尤其是在多人编辑或长期维护的博客项目中。标题结构跳级也常导致 Hexo 渲染页面时出现错乱，比如标题被误识为列表，页面结构紊乱。 本文聚焦两个核心问题： 如何统一给 Markdown 标题添加序号，以及如何清理已有的错误序号； 如何检测并规范标题等级跳级，避免 Hexo 渲染异常。 Part 1：统一添加 &#x2F; 删除标题序号1.1 使用 VS Code 插件自动添加序号推荐使用 VS Code 插件 Markdown All in One 来自动给 Markdown 标题添加序号。 安装插件后，使用命令面板（Ctrl+Shift+P）执行：Add/Update Section Numbers 该命令会遍历文档所有标题，自动添加类似如下的编号： 12## 1. 项目初始化### 1.1 安装依赖 注意： 目前该插件只能生成阿拉伯数字格式的序号； 它不会自动检测并删除已有的编号，重复执行可能导致序号重复。 1.2 删除已有标题序号（使用 Replace Rules）为了避免编号重复，建议先清理已有的编号。 使用 VS Code 插件 Replace Rules 可以批量替换文本，自动清理标题中的旧编号。 在工作区根目录下创建 .vscode/replace-rules.json 文件，写入如下规则： 1234567[ &#123; &quot;find&quot;: &quot;^(#&#123;2,6&#125;)\\s+(\\d+(\\.\\d+)*\\s+)(.*)&quot;, &quot;replace&quot;: &quot;$1 $4&quot;, &quot;flags&quot;: &quot;gm&quot; &#125;] 使用命令面板执行 Replace Rules: Run Rule，即可一键删除二级到六级标题中多余的数字编号。 Part 2：检测并规范标题跳级结构2.1 标题跳级问题简介Markdown 标题跳级指的是标题等级没有按顺序递增，常见示例： 123## 项目初始化#### 安装依赖## 功能介绍 这里，二级标题下直接出现了四级标题，导致 Hexo 渲染时后续的二级标题 功能介绍 被误认为是有序列表，造成排版和目录显示混乱。 2.2 使用 Markdownlint 检查标题结构通过 VS Code 插件 markdownlint 可以实时检测标题跳级问题。 安装插件后，在项目根目录创建 .markdownlint.json，启用标题层级规则： 1234&#123; &quot;default&quot;: false, &quot;MD001&quot;: true&#125; 规则说明： MD001 要求标题级别必须顺序递增，不允许跳级； 这样可以帮助你及时发现跳级错误，保证 Markdown 结构规范，避免 Hexo 渲染异常。 总结与推荐工作流推荐工作流程 检测标题跳级：使用 markdownlint 规范标题等级顺序，保证结构正确； 清理旧序号：用 Replace Rules 批量删除已有数字编号，避免重复； 添加新序号：用 Markdown All in One 插件统一生成阿拉伯数字格式序号； 最终校验并发布。 关键工具清单 Markdown All in One：自动添加标题序号 Replace Rules：清理旧的标题编号 markdownlint：检测标题跳级和其他规范问题 附录.markdownlint.json 示例配置1234&#123; &quot;default&quot;: false, &quot;MD001&quot;: true&#125; replace-rules.json 示例1234567[ &#123; &quot;find&quot;: &quot;^(#&#123;2,6&#125;)\\s+(\\d+(\\.\\d+)*\\s+)(.*)&quot;, &quot;replace&quot;: &quot;$1 $4&quot;, &quot;flags&quot;: &quot;gm&quot; &#125;]","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ai.he0xwhale.xyz/tags/Markdown/"},{"name":"标题序号","slug":"标题序号","permalink":"https://ai.he0xwhale.xyz/tags/%E6%A0%87%E9%A2%98%E5%BA%8F%E5%8F%B7/"},{"name":"博客规范","slug":"博客规范","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E8%A7%84%E8%8C%83/"}]},{"title":"使用 Hexo 搭建 AI 编程风格的吉卜力风博客","slug":"06/09/ai-ghibli-hexo-blog","date":"2025-06-08T21:57:04.000Z","updated":"2025-07-08T03:17:27.454Z","comments":true,"path":"2025/06/09/ai-ghibli-hexo-blog/","link":"","permalink":"https://ai.he0xwhale.xyz/2025/06/09/ai-ghibli-hexo-blog/","excerpt":"","text":"本文整合了我在搭建博客过程中的对话内容，系统地记录了使用 Hexo + Volantis 搭建一个 AI 编程主题的吉卜力风格博客的过程，包括部署、主题安装、美化、图标替换、壁纸设置与自动刷新等内容。 1. 项目初始化与环境准备1234npm install -g hexohexo init ai_blogcd ai_blognpm install 确认版本： 1hexo -v ✅ 为什么要确认版本？ Volantis 主题对 Hexo 有最低版本要求。根据 Volantis 官方文档，推荐使用 Hexo 6.3.0 或更高版本，以获得最佳兼容性和功能支持。 使用以上命令检查当前版本是否符合要求。如果你的 Hexo 版本低于要求，可以通过以下方式升级： 1npm install -g hexo@latest 2. 主题安装与配置 Volantis ✅ 推荐使用 Git 子模块的方式安装主题，以便未来方便升级、避免嵌套仓库冲突。 2.1. 安装 Volantis 主题（推荐方式 ✅） Fork Volantis 仓库到你自己的 GitHub 账户前往官方仓库：👉 https://github.com/volantis-x/hexo-theme-volantis点击右上角的 Fork，创建你自己的 Volantis 仓库，例如： 12https://github.com/your-username/hexo-theme-volantis 之所以这样做，是因为后面会对 volantis 的源码进行一些修改，通过_config.yml 的修改不起作用 将当前 themes&#x2F;volantis 绑定为你自己的 fork 1234567cd themes/volantis## 把当前 remote 改为你的 forkgit remote set-url origin https://github.com/your-username/hexo-theme-volantis## 检查 remote 是否设置正确git remote -v 你应该看到： 12origin https://github.com/your-username/hexo-theme-volantis (fetch)origin https://github.com/your-username/hexo-theme-volantis (push) 推送你当前本地修改到你自己的 fork（而不是官方） 添加官方仓库为 upstream 远程，方便后续同步更新 12git remote add upstream https://github.com/volantis-x/hexo-theme-volantis 将来如果官方有更新： 1234567## 拉取官方更新git fetch upstream## 合并你想要的分支，例如官方的 6.0git checkout custom-fontawesomegit merge upstream/6.0## 手动解决冲突并 commit 用 Git 子模块正式管理主题，使得整个流程更加清晰 1234## 在主 Hexo 项目根目录下执行git submodule add https://github.com/your-username/hexo-theme-volantis themes/volantisgit submodule initgit submodule update 这会将 volantis 主题作为一个 Git 子模块管理，优势如下： 便于更新：只需进入子模块目录 themes/volantis，运行 git pull 即可同步官方主题更新； 干净的仓库结构：不会将主题代码混入你的主仓库提交中； 避免冲突：防止主题目录被错误识别为嵌套 Git 仓库，减少 Git 管理异常。 2.2. ❌ 不推荐的方式（容易踩坑）1git clone https://github.com/volantis-x/hexo-theme-volantis.git themes/volantis 具体的原因可以参考第四部分内容：Volantis 子模块管理：踩坑与修复实录 2.3. 配置主题确认主题安装后，在 Hexo 根目录的 _config.yml 中添加： 1theme: volantis 3. 推送到 GitHub Pages3.1. 添加远程仓库12git initgit remote add origin https://github.com/yourname/ai_blog.git 3.2. 添加 .gitignore，忽略 public&#x2F; 与 node_modules&#x2F;.gitignore 文件正常应该已经包含了 public 和 node_modules，如果已经包含，请忽略这一步 12345echo &quot;public/&quot; &gt;&gt; .gitignoreecho &quot;node_modules/&quot; &gt;&gt; .gitignoregit add .git commit -m &quot;chore: initial commit&quot;git push -u origin main 3.3. 配置 Hexo 部署到 gh-pages1npm install hexo-deployer-git --save 12345## _config.ymldeploy: type: git repo: https://github.com/yourname/ai_blog.git branch: gh-pages 3.4. 发布博客1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 4. Volantis 子模块管理：踩坑与修复实录在最开始安装 Volantis 主题时，我直接执行了如下命令： 1git clone https://github.com/volantis-x/hexo-theme-volantis.git themes/volantis 看起来一切都很顺利，但当我尝试 git add . 时，Git 却抛出了一个警告： 1warning: 正在添加嵌入式 git 仓库：themes/volantis 这说明 themes/volantis 目录本身是一个 Git 仓库，等于你把一个完整的仓库嵌套到了你的博客仓库中。Git 不推荐这样做，除非使用子模块机制。否则未来推送或克隆项目时会遇到一堆问题，比如主题目录丢失、部署失败等。 4.1. ✅ 正确的解决方案 移除嵌套的 Git 仓库： 12git rm --cached -r themes/volantis -frm -rf themes/volantis 以子模块方式重新添加： 12git submodule add https://github.com/volantis-x/hexo-theme-volantis.git themes/volantisgit commit -m &quot;chore: convert volantis to git submodule&quot; 初始化并同步子模块： 12git submodule initgit submodule update 4.2. 🤔 如何一开始就避免这个坑？记住：安装 Hexo 主题时，推荐使用 git submodule add，而不是 git clone。 正确方式如下： 1git submodule add https://github.com/volantis-x/hexo-theme-volantis.git themes/volantis （如果需要修改 volantis 的源码，则另外需要 fork 一份，按照上面第二步的操作进行）这样做的好处是结构清晰、维护方便，更新主题也简单，只需进入子模块目录执行： 12cd themes/volantisgit pull origin master 4.3. 🔄 后续管理提醒若以后在新机器上克隆项目，需加上 --recursive 选项： 1git clone --recursive https://github.com/yourname/ai_blog.git 或补执行以下命令： 12git submodule initgit submodule update 5. 字体与图标美化5.1. 替换网站 favicon 图标12## _config.ymlfavicon: /favicon.ico 上传你自己的图标至 source/ 目录。 5.2. 替换 Logo 与博主头像12345678## _config.volantis.ymlnavbar: logo: img: /images/logo-ghibli-ai.pngsidebar: blogger: avatar: /images/logo-ghibli-ai.png 5.3. 首页封面布局简化改用简洁风格 12cover: layout_scheme: simple 5.4. 更换博客背景图为 AI 吉卜力风12cover: background: /images/bg-ai-ghibli.jpg 6. Font Awesome 字体本地化6.1. 目标避免 CDN 依赖，提升加载速度与离线浏览体验。 6.2. 修改步骤步骤： 1.下载这两个字体文件在你的项目中（建议放到 themes&#x2F;volantis&#x2F;source&#x2F;media&#x2F;fonts 目录）： 123456mkdir -p themes/volantis/source/media/fonts/VarelaRoundmkdir -p themes/volantis/source/media/fonts/UbuntuMono## 下载字体wget https://unpkg.com/volantis-static/media/fonts/VarelaRound/VarelaRound-Regular.ttf -O themes/volantis/source/media/fonts/VarelaRound/VarelaRound-Regular.ttfwget https://unpkg.com/volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf -O themes/volantis/source/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf 打开 &#x2F;css&#x2F;all.min.css，搜索类似： 1src: url(&quot;../webfonts/fa-solid-900.woff2&quot;) format(&quot;woff2&quot;); 这个路径表示的是从 HTML 中 &#x2F;css&#x2F;all.min.css 出发，回退到根目录后访问 &#x2F;webfonts&#x2F;，这在你的部署目录下应当是： 12public/css/all.min.csspublic/webfonts/*.woff2 将 CSS 中路径手动替换为绝对路径： 12src: url(&quot;/webfonts/fa-solid-900.woff2&quot;) format(&quot;woff2&quot;); 修改 theme&#x2F;_config.yml： 12plugins: fontawesome: false | 意思是：不要让 Volantis 插件插入 Font Awesome 的 CSS，我们手动插入 在 themes&#x2F;volantis&#x2F;layout&#x2F;_partials&#x2F;head&#x2F;head.ejs 中，手动添加这段（确保放在合适位置，比如 末尾）： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= url_for(&#x27;/css/all.min.css&#x27;) %&gt;&quot;&gt; 确保你本地的 themes&#x2F;volantis&#x2F;source&#x2F;css&#x2F;all.min.css 和 webfonts 文件夹都已就位 6.3. Git 提交1234cd themes/volantisgit add source/webfonts/*.woff2git add source/css/all.min.cssgit commit -m &quot;feat: 使用本地 Font Awesome 字体，替换 CDN&quot; 注意：这只影响子模块内，避免影响官方仓库建议在 GitHub 上 fork Volantis 仓库再作为子模块使用。 7. Hexo 开发效率优化与自动刷新7.1. 安装 browser-sync 插件1npm install browser-sync --save-dev 7.2. 自动生效体验在使用 hexo s --draft --open 时 Hexo 会自动集成 browser-sync，页面保存后自动热更新生效。 7.3. 清理遗留 public 文件切换到 gh-pages 分支部署后，main 分支不再需要保留 public/ 内容： 1git rm -r --cached public/ 确认 .gitignore 中已添加 public/ 条目。 8. 自动化部署脚本deploy.sh 12345678910111213141516171819202122232425#!/bin/bashset -e # 出错即停echo &quot;🧹 Cleaning cache and public folder...&quot;hexo cleanecho &quot;📦 Generating static files...&quot;hexo generateecho &quot;🚀 Deploying to GitHub Pages...&quot;hexo deployecho &quot;✅ Hexo deploy finished.&quot;## 交互式输入 commit messageread -p &quot;📝 Enter commit message for source code: &quot; commit_msgecho &quot;📁 Committing source code to Git repository...&quot;git add .git commit -m &quot;$commit_msg&quot;git push origin mainecho &quot;🎉 All done!&quot; 使用方法： 保存脚本为 deploy.sh 赋予执行权限（仅第一次）： 1chmod +x deploy.sh 每次发布时执行： 1./deploy.sh 9. 总结本次博客搭建过程较为完整，期间踩坑不少，如 Git 子模块管理、Volantis 子仓库嵌套、字体本地化路径、Hexo 部署分支等。也收获很多： 将博客部署到 gh-pages 分支，主仓库保持干净 美化 Logo、背景、图标统一风格 替换外部依赖为本地资源，提升加载速度 自动化开发环境，大幅提升效率 🌐 博客地址：https://ai.he0xwhale.xyz","categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://ai.he0xwhale.xyz/tags/GitHub-Pages/"},{"name":"博客美化","slug":"博客美化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"AI编程","slug":"AI编程","permalink":"https://ai.he0xwhale.xyz/tags/AI%E7%BC%96%E7%A8%8B/"},{"name":"吉卜力风","slug":"吉卜力风","permalink":"https://ai.he0xwhale.xyz/tags/%E5%90%89%E5%8D%9C%E5%8A%9B%E9%A3%8E/"}]}],"categories":[{"name":"博客之旅","slug":"博客之旅","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"},{"name":"问题排查","slug":"博客之旅/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"技术分享","slug":"技术分享","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"问题排查","slug":"技术分享/问题排查","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"Gemini","slug":"技术分享/Gemini","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Gemini/"},{"name":"基础搭建","slug":"博客之旅/基础搭建","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"},{"name":"美化定制","slug":"博客之旅/美化定制","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E7%BE%8E%E5%8C%96%E5%AE%9A%E5%88%B6/"},{"name":"开发实战","slug":"技术分享/开发实战","permalink":"https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"},{"name":"优化推广","slug":"博客之旅/优化推广","permalink":"https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E4%BC%98%E5%8C%96%E6%8E%A8%E5%B9%BF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ai.he0xwhale.xyz/tags/Hexo/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"前端调试","slug":"前端调试","permalink":"https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"},{"name":"Debugging","slug":"Debugging","permalink":"https://ai.he0xwhale.xyz/tags/Debugging/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://ai.he0xwhale.xyz/tags/Butterfly/"},{"name":"Configuration","slug":"Configuration","permalink":"https://ai.he0xwhale.xyz/tags/Configuration/"},{"name":"Front-end","slug":"Front-end","permalink":"https://ai.he0xwhale.xyz/tags/Front-end/"},{"name":"Volantis","slug":"Volantis","permalink":"https://ai.he0xwhale.xyz/tags/Volantis/"},{"name":"多语言","slug":"多语言","permalink":"https://ai.he0xwhale.xyz/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"},{"name":"博客","slug":"博客","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ai.he0xwhale.xyz/tags/JavaScript/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"排障记录","slug":"排障记录","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8E%92%E9%9A%9C%E8%AE%B0%E5%BD%95/"},{"name":"i18n","slug":"i18n","permalink":"https://ai.he0xwhale.xyz/tags/i18n/"},{"name":"国际化","slug":"国际化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"博客恢复","slug":"博客恢复","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://ai.he0xwhale.xyz/tags/VS-Code/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://ai.he0xwhale.xyz/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","permalink":"https://ai.he0xwhale.xyz/tags/Webpack/"},{"name":"Node.js","slug":"Node-js","permalink":"https://ai.he0xwhale.xyz/tags/Node-js/"},{"name":"Gemini","slug":"Gemini","permalink":"https://ai.he0xwhale.xyz/tags/Gemini/"},{"name":"CLI","slug":"CLI","permalink":"https://ai.he0xwhale.xyz/tags/CLI/"},{"name":"认证","slug":"认证","permalink":"https://ai.he0xwhale.xyz/tags/%E8%AE%A4%E8%AF%81/"},{"name":"代理","slug":"代理","permalink":"https://ai.he0xwhale.xyz/tags/%E4%BB%A3%E7%90%86/"},{"name":"网络","slug":"网络","permalink":"https://ai.he0xwhale.xyz/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://ai.he0xwhale.xyz/tags/Troubleshooting/"},{"name":"博客优化","slug":"博客优化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"},{"name":"CSS","slug":"CSS","permalink":"https://ai.he0xwhale.xyz/tags/CSS/"},{"name":"博客主题","slug":"博客主题","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"},{"name":"吉卜力","slug":"吉卜力","permalink":"https://ai.he0xwhale.xyz/tags/%E5%90%89%E5%8D%9C%E5%8A%9B/"},{"name":"Git","slug":"Git","permalink":"https://ai.he0xwhale.xyz/tags/Git/"},{"name":"Git Submodule","slug":"Git-Submodule","permalink":"https://ai.he0xwhale.xyz/tags/Git-Submodule/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ai.he0xwhale.xyz/tags/Markdown/"},{"name":"Bug排查","slug":"Bug排查","permalink":"https://ai.he0xwhale.xyz/tags/Bug%E6%8E%92%E6%9F%A5/"},{"name":"VSCode","slug":"VSCode","permalink":"https://ai.he0xwhale.xyz/tags/VSCode/"},{"name":"Cursor","slug":"Cursor","permalink":"https://ai.he0xwhale.xyz/tags/Cursor/"},{"name":"插件开发","slug":"插件开发","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"SEO","slug":"SEO","permalink":"https://ai.he0xwhale.xyz/tags/SEO/"},{"name":"OpenGraph","slug":"OpenGraph","permalink":"https://ai.he0xwhale.xyz/tags/OpenGraph/"},{"name":"结构化数据","slug":"结构化数据","permalink":"https://ai.he0xwhale.xyz/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/"},{"name":"搜索引擎优化","slug":"搜索引擎优化","permalink":"https://ai.he0xwhale.xyz/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"},{"name":"字数统计","slug":"字数统计","permalink":"https://ai.he0xwhale.xyz/tags/%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/"},{"name":"博客封面图","slug":"博客封面图","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2%E5%9B%BE/"},{"name":"实践记录","slug":"实践记录","permalink":"https://ai.he0xwhale.xyz/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"},{"name":"插图","slug":"插图","permalink":"https://ai.he0xwhale.xyz/tags/%E6%8F%92%E5%9B%BE/"},{"name":"博客技巧","slug":"博客技巧","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/"},{"name":"博客页面","slug":"博客页面","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/"},{"name":"分类标签","slug":"分类标签","permalink":"https://ai.he0xwhale.xyz/tags/%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE/"},{"name":"友链页面","slug":"友链页面","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2/"},{"name":"评论系统","slug":"评论系统","permalink":"https://ai.he0xwhale.xyz/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Giscus","slug":"Giscus","permalink":"https://ai.he0xwhale.xyz/tags/Giscus/"},{"name":"GitHub Discussions","slug":"GitHub-Discussions","permalink":"https://ai.he0xwhale.xyz/tags/GitHub-Discussions/"},{"name":"标题序号","slug":"标题序号","permalink":"https://ai.he0xwhale.xyz/tags/%E6%A0%87%E9%A2%98%E5%BA%8F%E5%8F%B7/"},{"name":"博客规范","slug":"博客规范","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E8%A7%84%E8%8C%83/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://ai.he0xwhale.xyz/tags/GitHub-Pages/"},{"name":"博客美化","slug":"博客美化","permalink":"https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"AI编程","slug":"AI编程","permalink":"https://ai.he0xwhale.xyz/tags/AI%E7%BC%96%E7%A8%8B/"},{"name":"吉卜力风","slug":"吉卜力风","permalink":"https://ai.he0xwhale.xyz/tags/%E5%90%89%E5%8D%9C%E5%8A%9B%E9%A3%8E/"}]}