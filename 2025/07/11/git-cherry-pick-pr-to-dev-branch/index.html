<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick) | AI WHALE</title><meta name="author" content="he0xwhale"><meta name="copyright" content="he0xwhale"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言在参与开源项目或团队协作时，我们通常会从一个开发分支（如 dev 或 develop）拉取一个特性分支进行开发，完成功能或 Bug 修复后，向主分支（如 main 或 master）提交 Pull Request (PR)。一旦 PR 被合并，我们的修改就进入了主分支。 然而，有时我们希望将 PR 的内容也同步回我们的开发分支（例如 dev 分支），以便本地开发环境保持最新，或者将该修改作为后">
<meta property="og:type" content="article">
<meta property="og:title" content="Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)">
<meta property="og:url" content="https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/index.html">
<meta property="og:site_name" content="AI WHALE">
<meta property="og:description" content="引言在参与开源项目或团队协作时，我们通常会从一个开发分支（如 dev 或 develop）拉取一个特性分支进行开发，完成功能或 Bug 修复后，向主分支（如 main 或 master）提交 Pull Request (PR)。一旦 PR 被合并，我们的修改就进入了主分支。 然而，有时我们希望将 PR 的内容也同步回我们的开发分支（例如 dev 分支），以便本地开发环境保持最新，或者将该修改作为后">
<meta property="og:locale">
<meta property="og:image" content="https://ai.he0xwhale.xyz/images/cover/git-cherry-pick-pr-to-dev-branch.png">
<meta property="article:published_time" content="2025-07-11T08:30:00.000Z">
<meta property="article:modified_time" content="2025-07-11T08:24:14.248Z">
<meta property="article:author" content="he0xwhale">
<meta property="article:tag" content="踩坑记录">
<meta property="article:tag" content="Git">
<meta property="article:tag" content="GitHub">
<meta property="article:tag" content="Pull Request">
<meta property="article:tag" content="cherry-pick">
<meta property="article:tag" content="分支管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ai.he0xwhale.xyz/images/cover/git-cherry-pick-pr-to-dev-branch.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)",
  "url": "https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/",
  "image": "https://ai.he0xwhale.xyz/images/cover/git-cherry-pick-pr-to-dev-branch.png",
  "datePublished": "2025-07-11T08:30:00.000Z",
  "dateModified": "2025-07-11T08:24:14.248Z",
  "author": [
    {
      "@type": "Person",
      "name": "he0xwhale",
      "url": "https://ai.he0xwhale.xyz"
    }
  ]
}</script><link rel="shortcut icon" href="/images/website/favicon.ico"><link rel="canonical" href="https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="AI WHALE" type="application/atom+xml">
</head><body><div id="web_bg" style="background-color: #fff8e7;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/website/logo_2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-rss"></i><span> 博客</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-solid fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-solid fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-info-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/cover/git-cherry-pick-pr-to-dev-branch.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/website/logo.png" alt="Logo"><span class="site-name">AI WHALE</span></a><a class="nav-page-title" href="/"><span class="site-name">Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-rss"></i><span> 博客</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-solid fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-solid fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-info-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-11T08:30:00.000Z" title="发表于 2025-07-11 16:30:00">2025-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-11T08:24:14.248Z" title="更新于 2025-07-11 16:24:14">2025-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Git%E5%AE%9E%E8%B7%B5/">Git实践</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在参与开源项目或团队协作时，我们通常会从一个开发分支（如 <code>dev</code> 或 <code>develop</code>）拉取一个特性分支进行开发，完成功能或 Bug 修复后，向主分支（如 <code>main</code> 或 <code>master</code>）提交 Pull Request (PR)。一旦 PR 被合并，我们的修改就进入了主分支。</p>
<p>然而，有时我们希望将 PR 的内容也同步回我们的开发分支（例如 <code>dev</code> 分支），以便本地开发环境保持最新，或者将该修改作为后续开发的基础。本文将详细介绍如何使用 Git 的 <code>cherry-pick</code> 命令来实现这一目标，并分享我在实际操作中遇到的问题及解决方案。</p>
<h2 id="什么是-git-cherry-pick？"><a href="#什么是-git-cherry-pick？" class="headerlink" title="什么是 git cherry-pick？"></a>什么是 <code>git cherry-pick</code>？</h2><p><code>git cherry-pick</code> 命令的作用是将一个或多个现有提交应用到当前分支。它会复制指定提交的更改，并在当前分支上创建一个新的提交。这与 <code>git merge</code> 或 <code>git rebase</code> 不同，<code>cherry-pick</code> 只挑选特定的提交，而不是合并整个分支的历史。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>将其他分支的单个或少量提交合并到当前分支。</li>
<li>将已合并到主分支的 PR 提交，同步回开发分支。</li>
<li>从一个特性分支中挑选出部分提交，应用到另一个特性分支。</li>
</ul>
<h2 id="操作步骤：将-PR-提交同步到-dev-分支"><a href="#操作步骤：将-PR-提交同步到-dev-分支" class="headerlink" title="操作步骤：将 PR 提交同步到 dev 分支"></a>操作步骤：将 PR 提交同步到 <code>dev</code> 分支</h2><p>假设您已经将 <code>fix-page-cover</code> 分支上的 Bug 修复提交到了官方仓库，并且现在希望将这个修复也应用到您的本地 <code>dev</code> 分支。</p>
<h3 id="1-确认当前分支"><a href="#1-确认当前分支" class="headerlink" title="1. 确认当前分支"></a>1. 确认当前分支</h3><p>首先，确保您当前位于目标分支，即您希望应用 PR 提交的分支（例如 <code>dev</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不在 dev 分支，切换到 dev</span></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

<h3 id="2-查找-PR-提交的-SHA-值"><a href="#2-查找-PR-提交的-SHA-值" class="headerlink" title="2. 查找 PR 提交的 SHA 值"></a>2. 查找 PR 提交的 SHA 值</h3><p>您需要找到包含您 PR 内容的那个提交的 SHA 值。如果您是在一个专门的特性分支上完成的 PR，那么这个提交通常是该特性分支的最后一个提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 fix-page-cover 分支的提交历史</span></span><br><span class="line"><span class="comment"># 找到包含 PR 内容的提交（通常是您为 PR 编写的 commit message）</span></span><br><span class="line">git <span class="built_in">log</span> --oneline fix-page-cover</span><br></pre></td></tr></table></figure>

<p>例如，您可能会看到类似这样的输出：<br><code>8ae23cf Fix: Display cover images for categories and tags pages</code><br>这里的 <code>8ae23cf</code> 就是您需要的提交 SHA 值。</p>
<h3 id="3-执行-git-cherry-pick"><a href="#3-执行-git-cherry-pick" class="headerlink" title="3. 执行 git cherry-pick"></a>3. 执行 <code>git cherry-pick</code></h3><p>现在，在您的 <code>dev</code> 分支上执行 <code>cherry-pick</code> 命令，将找到的提交应用过来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 dev 分支上执行</span></span><br><span class="line">git cherry-pick &lt;提交的 SHA 值&gt;</span><br><span class="line"><span class="comment"># 例如：git cherry-pick 8ae23cf</span></span><br></pre></td></tr></table></figure>

<p>如果一切顺利，Git 会将该提交的更改应用到您的 <code>dev</code> 分支，并创建一个新的提交。</p>
<h2 id="常见问题及排查"><a href="#常见问题及排查" class="headerlink" title="常见问题及排查"></a>常见问题及排查</h2><p>在 <code>cherry-pick</code> 过程中，您可能会遇到一些问题。</p>
<h3 id="问题场景-1：git-log-提示“有歧义的参数”或“路径未匹配任何-git-已知文件”"><a href="#问题场景-1：git-log-提示“有歧义的参数”或“路径未匹配任何-git-已知文件”" class="headerlink" title="问题场景 1：git log 提示“有歧义的参数”或“路径未匹配任何 git 已知文件”"></a>问题场景 1：<code>git log</code> 提示“有歧义的参数”或“路径未匹配任何 git 已知文件”</h3><p><strong>问题描述</strong>：当您尝试使用 <code>git log --oneline &lt;branch&gt; &lt;file_path&gt;</code> 这样的命令来查找特定文件的提交历史时，Git 可能会报错。</p>
<p><strong>排查与解决</strong>：这是因为在 Git 命令中同时指定分支和文件路径时，需要使用 <code>--</code> 来明确分隔它们，以消除歧义。</p>
<ul>
<li><strong>解决方案</strong>：在文件路径前添加 <code>--</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline fix-page-cover -- themes/butterfly/layout/includes/header/index.pug</span><br></pre></td></tr></table></figure>
如果您不确定具体的文件路径，或者只想查看整个分支的提交历史，可以直接使用 <code>git log --oneline &lt;branch&gt;</code>。</li>
</ul>
<h3 id="问题场景-2：git-cherry-pick-提示“无文件要提交，干净的工作区”-“空提交”"><a href="#问题场景-2：git-cherry-pick-提示“无文件要提交，干净的工作区”-“空提交”" class="headerlink" title="问题场景 2：git cherry-pick 提示“无文件要提交，干净的工作区” &#x2F; “空提交”"></a>问题场景 2：<code>git cherry-pick</code> 提示“无文件要提交，干净的工作区” &#x2F; “空提交”</h3><p><strong>问题描述</strong>：在执行 <code>git cherry-pick</code> 后，Git 提示“无文件要提交，干净的工作区”，并说明这是一个“空提交”。</p>
<p><strong>排查与解决</strong>：这表明您当前分支的工作区已经包含了要 <code>cherry-pick</code> 的提交所引入的所有修改。Git 发现当前分支的文件内容与目标提交的修改是相同的，因此没有实际的更改需要应用，从而生成了一个空提交。</p>
<ul>
<li><strong>解决方案</strong>：由于没有实际的修改，您可以直接跳过这个空提交，结束 <code>cherry-pick</code> 进程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --skip</span><br></pre></td></tr></table></figure>
这通常意味着您之前已经通过其他方式（例如手动复制粘贴，或者更早的 <code>cherry-pick</code> 操作）将这些修改应用到了当前分支。</li>
</ul>
<h3 id="问题场景-3：git-push-提示“无效引用：upstream-dev”"><a href="#问题场景-3：git-push-提示“无效引用：upstream-dev”" class="headerlink" title="问题场景 3：git push 提示“无效引用：upstream&#x2F;dev”"></a>问题场景 3：<code>git push</code> 提示“无效引用：upstream&#x2F;dev”</h3><p><strong>问题描述</strong>：当您尝试从 <code>upstream</code> 远程仓库检出文件时（例如 <code>git checkout upstream/dev -- &lt;file&gt;</code>），Git 提示“无效引用：upstream&#x2F;dev”。</p>
<p><strong>排查与解决</strong>：这表明您的本地仓库还没有从 <code>upstream</code> 远程仓库抓取最新的分支信息。</p>
<ul>
<li><strong>解决方案</strong>：先执行 <code>git fetch upstream</code> 命令，将 <code>upstream</code> 远程仓库的所有分支信息同步到本地。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure>
然后再次尝试 <code>git checkout upstream/dev -- &lt;file&gt;</code>。</li>
</ul>
<h3 id="问题场景-4：git-push-提示“无法推送一些引用到…”-例如-error-源引用规格-dev-没有匹配"><a href="#问题场景-4：git-push-提示“无法推送一些引用到…”-例如-error-源引用规格-dev-没有匹配" class="headerlink" title="问题场景 4：git push 提示“无法推送一些引用到…” (例如 error: 源引用规格 dev 没有匹配)"></a>问题场景 4：<code>git push</code> 提示“无法推送一些引用到…” (例如 <code>error: 源引用规格 dev 没有匹配</code>)</h3><p><strong>问题描述</strong>：在主仓库执行 <code>git push</code> 时，提示与分支引用相关的错误。</p>
<p><strong>排查与解决</strong>：这通常是因为您本地仓库的当前分支与远程仓库的期望分支不匹配，或者远程仓库没有您尝试推送的那个分支。</p>
<ul>
<li><strong>解决方案</strong>：<ol>
<li><strong>确认当前分支</strong>：使用 <code>git branch</code> 确认您当前所在的分支。</li>
<li><strong>确认远程仓库的分支结构</strong>：使用 <code>git remote show origin</code> 查看 <code>origin</code> 远程仓库的 HEAD 分支和已跟踪的分支。</li>
<li><strong>匹配推送目标</strong>：确保您 <code>git push</code> 的本地分支与远程目标分支是匹配的。例如，如果您的主仓库默认分支是 <code>main</code>，而您尝试推送到 <code>dev</code>，就会报错。您需要将 <code>git push origin dev</code> 修改为 <code>git push origin main</code>（或您实际的主分支名）。</li>
<li><strong>第一次推送新分支</strong>：如果您是第一次将本地分支推送到远程，需要使用 <code>-u</code> 参数设置上游跟踪：<code>git push -u origin &lt;branch_name&gt;</code>。</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>git cherry-pick</code> 是一个非常实用的 Git 命令，可以帮助我们在复杂的协作流程中精确地管理提交。通过本文的介绍，您应该能够掌握如何将 Pull Request 的提交内容同步到开发分支，并解决过程中可能遇到的一些常见 Git 问题。熟练运用这些 Git 技巧，将使您的开发流程更加顺畅高效。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ai.he0xwhale.xyz">he0xwhale</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/">https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ai.he0xwhale.xyz" target="_blank">AI WHALE</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">踩坑记录</a><a class="post-meta__tags" href="/tags/Git/">Git</a><a class="post-meta__tags" href="/tags/GitHub/">GitHub</a><a class="post-meta__tags" href="/tags/Pull-Request/">Pull Request</a><a class="post-meta__tags" href="/tags/cherry-pick/">cherry-pick</a><a class="post-meta__tags" href="/tags/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/">分支管理</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/git-cherry-pick-pr-to-dev-branch.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/11/hexo-volantis-to-butterfly-migration-guide/" title="Hexo Volantis 到 Butterfly 主题迁移指南"><img class="cover" src="/images/cover/hexo-volantis-to-butterfly-migration-guide.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hexo Volantis 到 Butterfly 主题迁移指南</div></div><div class="info-2"><div class="info-item-1">前言Hexo 作为一款优秀的静态博客框架，拥有丰富的社区主题。我曾长期使用 Volantis 主题，其强大的自定义能力和精美的设计给我留下了深刻印象。然而，随着博客的不断发展，为了寻求更简洁、高效且同样美观的体验，我决定将博客主题从 Volantis 迁移到 Butterfly。 迁移计划回顾与差异分析在开始迁移之前，我制定了一份详细的迁移计划。这份计划帮助我系统地对比了两个主题在导航栏、封面、文章布局、评论系统和个性化元素等方面的配置差异。 1. 导航栏 (Navbar) 配置 差异分析：Volantis 和 Butterfly 在导航栏菜单项的配置方式上有所不同。Volantis 提供了非常灵活的自定义选项，包括图标和链接的直接配置。Butterfly 同样支持自定义菜单，但其图标通常通过 Font Awesome 类名来指定，且配置结构更加扁平化。  解决方案：在 Butterfly 的 themes/butterfly/_config.yml 中，找到 menu 部分，按照其格式添加或修改菜单项。对于图标，需要查阅 Font Awesome 图标库，找到对应的类名并添加到...</div></div></div></a><a class="pagination-related" href="/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/" title="Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查"><img class="cover" src="/images/cover/hexo-butterfly-pr-git-troubleshooting-guide.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查</div></div><div class="info-2"><div class="info-item-1"> 本文是关于向 Hexo Butterfly 主题提交 Pull Request 过程中，我所经历的 Git 实践流程，以及期间遇到的典型问题和解决方案的总结。   📌 重要注意事项本次 Pull Request 的出发点是解决一个关于 Hexo Butterfly 主题分类页和标签页封面图不显示的问题。在 PR 过程中，我得到了主题作者的反馈，这修正了我对 themes/butterfly/_config.yml 中 category_img 和 tag_img 配置项的理解。 核心 Bug 根源的修正理解：  最初的误解：我曾认为 category_img 和 tag_img 是用于设置分类页 /categories/ 和标签页 /tags/ 主页的封面图。 正确的理解：category_img 和 tag_img 实际上是为文章（posts）在分类&#x2F;标签归档页面中提供一个备用的封面图。而分类页 /categories/ 和标签页 /tags/ 的主封面图，应该在它们各自的 Markdown 文件（例如 source/categories/index.md 和 s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/" title="Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查"><img class="cover" src="/images/cover/hexo-butterfly-pr-git-troubleshooting-guide.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="info-item-2">Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查</div></div><div class="info-2"><div class="info-item-1"> 本文是关于向 Hexo Butterfly 主题提交 Pull Request 过程中，我所经历的 Git 实践流程，以及期间遇到的典型问题和解决方案的总结。   📌 重要注意事项本次 Pull Request 的出发点是解决一个关于 Hexo Butterfly 主题分类页和标签页封面图不显示的问题。在 PR 过程中，我得到了主题作者的反馈，这修正了我对 themes/butterfly/_config.yml 中 category_img 和 tag_img 配置项的理解。 核心 Bug 根源的修正理解：  最初的误解：我曾认为 category_img 和 tag_img 是用于设置分类页 /categories/ 和标签页 /tags/ 主页的封面图。 正确的理解：category_img 和 tag_img 实际上是为文章（posts）在分类&#x2F;标签归档页面中提供一个备用的封面图。而分类页 /categories/ 和标签页 /tags/ 的主封面图，应该在它们各自的 Markdown 文件（例如 source/categories/index.md 和 s...</div></div></div></a><a class="pagination-related" href="/2025/06/17/vscode-cursor-plugin-issue/" title="用 Cursor 开发 VSCode 插件时遇到的版本兼容性问题排查实录"><img class="cover" src="/images/cover/vscode-cursor-plugin-issue.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">用 Cursor 开发 VSCode 插件时遇到的版本兼容性问题排查实录</div></div><div class="info-2"><div class="info-item-1">VSCode 插件在 Cursor 不能用？一次环境兼容性大坑的排查与解决最近在开发 VSCode 插件时，遇到了一个非常隐蔽但又很有代表性的大坑：插件在官方 VSCode 客户端中一切正常，但在 Cursor 编辑器中死活激活不了，命令也不显示。 这篇文章记录我的排查过程、最终的解决办法，以及一些经验教训，希望能帮到遇到类似问题的你。 问题描述我写了一个 VSCode 插件，在官方 VSCode 客户端里可以正常激活和使用，命令也能正常显示。但当我切换到 Cursor 编辑器，发现插件根本没有被激活，命令也找不到。 我反复检查代码、配置，依赖也都装了，编译也没报错，就是不行！ 排查过程1. 常规排查 重新安装依赖（pnpm install） 重新编译（pnpm run compile） 检查 package.json 配置 查看输出面板和调试控制台  结果都没有发现明显问题。 2. 环境对比（真实心路）其实在排查过程中，我并没有第一时间注意到 VSCode 和 Cursor 的底层版本差异。一开始只是觉得它们界面很像，理所当然地以为插件兼容性不会有大问题。 直到我在向 Chat...</div></div></div></a><a class="pagination-related" href="/2025/07/09/hexo-butterfly-cover-image-debug-story/" title="一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录"><img class="cover" src="/images/cover/hexo-butterfly-cover-image-debug-story.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录</div></div><div class="info-2"><div class="info-item-1"> 在搭建和美化 Hexo 博客的过程中，我们时常会遇到一些看似简单，却足以让人抓狂的“灵异事件”。最近，我就和我的 AI 助手 Roo 经历了一次这样的封面图调试之旅。一个简单的图片不显示问题，我们排查了代码、配置、路径，甚至怀疑人生，最终却发现“真凶”隐藏在一个意想不到的地方。  这篇文章记录了我们完整的调试过程，希望能为同样在 Hexo 世界中探索的你提供一些有价值的参考和避坑指南。  📌 重要更新与注意事项（2025-07-11）在 Pull Request 中，我得到了主题作者的反馈，这修正了我对 themes/butterfly/_config.yml 中 category_img 和 tag_img 配置项的理解。 最初的误解： 本文最初的问题提出（“不听话的 category_img 和 tag_img”）是基于一个误解，认为 category_img 和 tag_img 是用于设置分类页 /categories/ 和标签页 /tags/ 主页的封面图。 正确的理解：  category_img 和 tag_img 配置项，实际上是用于设置当文章没有指定 cove...</div></div></div></a><a class="pagination-related" href="/2025/06/19/hexo_submodule_split_blog/" title="从 Hexo 模板创建新博客并独立管理 Volantis 子模块的完整过程"><img class="cover" src="/images/cover/hexo_submodule_split_blog.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="info-item-2">从 Hexo 模板创建新博客并独立管理 Volantis 子模块的完整过程</div></div><div class="info-2"><div class="info-item-1">在 Hexo 博客搭建中，很多用户会选择将主题如 Volantis 作为子模块管理以便于后续更新。然而，如果你想以现有的博客为模板创建新的博客，并保留主题改动，同时又不希望多个项目之间相互干扰，合理管理 Git 子模块就显得非常重要。 本文记录了一个完整的实践过程，包含遇到的问题、原因分析和最终的解决方法。 场景说明 已有博客项目：ai_blog，使用 fork 的 Volantis 主题作为 Git 子模块，且 _config.yml 中做了大量定制修改； 目标：创建一个新博客 tech_blog，以 ai_blog 为基础模板，但希望主题配置独立； 遇到的问题包括：子模块复用导致冲突、分支不同步、远程混乱、推送失败等。   一、从模板创建新项目12345678910111213# 克隆 ai_blog，包括子模块git clone --recursive https://github.com/yourname/ai_blog.git tech_blogcd tech_blog# 删除旧 git 记录，准备建立新仓库rm -rf .gitgit init# 重新添加远程并提交g...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/website/logo_2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">he0xwhale</div><div class="author-info-description">A blog dedicated to AI, technology, and innovation.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/he0xwhale"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-git-cherry-pick%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是 git cherry-pick？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%EF%BC%9A%E5%B0%86-PR-%E6%8F%90%E4%BA%A4%E5%90%8C%E6%AD%A5%E5%88%B0-dev-%E5%88%86%E6%94%AF"><span class="toc-number">3.</span> <span class="toc-text">操作步骤：将 PR 提交同步到 dev 分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AE%E8%AE%A4%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF"><span class="toc-number">3.1.</span> <span class="toc-text">1. 确认当前分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE-PR-%E6%8F%90%E4%BA%A4%E7%9A%84-SHA-%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">2. 查找 PR 提交的 SHA 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C-git-cherry-pick"><span class="toc-number">3.3.</span> <span class="toc-text">3. 执行 git cherry-pick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8E%92%E6%9F%A5"><span class="toc-number">4.</span> <span class="toc-text">常见问题及排查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-1%EF%BC%9Agit-log-%E6%8F%90%E7%A4%BA%E2%80%9C%E6%9C%89%E6%AD%A7%E4%B9%89%E7%9A%84%E5%8F%82%E6%95%B0%E2%80%9D%E6%88%96%E2%80%9C%E8%B7%AF%E5%BE%84%E6%9C%AA%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95-git-%E5%B7%B2%E7%9F%A5%E6%96%87%E4%BB%B6%E2%80%9D"><span class="toc-number">4.1.</span> <span class="toc-text">问题场景 1：git log 提示“有歧义的参数”或“路径未匹配任何 git 已知文件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-2%EF%BC%9Agit-cherry-pick-%E6%8F%90%E7%A4%BA%E2%80%9C%E6%97%A0%E6%96%87%E4%BB%B6%E8%A6%81%E6%8F%90%E4%BA%A4%EF%BC%8C%E5%B9%B2%E5%87%80%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8C%BA%E2%80%9D-%E2%80%9C%E7%A9%BA%E6%8F%90%E4%BA%A4%E2%80%9D"><span class="toc-number">4.2.</span> <span class="toc-text">问题场景 2：git cherry-pick 提示“无文件要提交，干净的工作区” &#x2F; “空提交”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-3%EF%BC%9Agit-push-%E6%8F%90%E7%A4%BA%E2%80%9C%E6%97%A0%E6%95%88%E5%BC%95%E7%94%A8%EF%BC%9Aupstream-dev%E2%80%9D"><span class="toc-number">4.3.</span> <span class="toc-text">问题场景 3：git push 提示“无效引用：upstream&#x2F;dev”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-4%EF%BC%9Agit-push-%E6%8F%90%E7%A4%BA%E2%80%9C%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81%E4%B8%80%E4%BA%9B%E5%BC%95%E7%94%A8%E5%88%B0%E2%80%A6%E2%80%9D-%E4%BE%8B%E5%A6%82-error-%E6%BA%90%E5%BC%95%E7%94%A8%E8%A7%84%E6%A0%BC-dev-%E6%B2%A1%E6%9C%89%E5%8C%B9%E9%85%8D"><span class="toc-number">4.4.</span> <span class="toc-text">问题场景 4：git push 提示“无法推送一些引用到…” (例如 error: 源引用规格 dev 没有匹配)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/11/hexo-volantis-to-butterfly-migration-guide/" title="Hexo Volantis 到 Butterfly 主题迁移指南"><img src="/images/cover/hexo-volantis-to-butterfly-migration-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo Volantis 到 Butterfly 主题迁移指南"/></a><div class="content"><a class="title" href="/2025/07/11/hexo-volantis-to-butterfly-migration-guide/" title="Hexo Volantis 到 Butterfly 主题迁移指南">Hexo Volantis 到 Butterfly 主题迁移指南</a><time datetime="2025-07-11T08:40:00.000Z" title="发表于 2025-07-11 16:40:00">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/11/git-cherry-pick-pr-to-dev-branch/" title="Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)"><img src="/images/cover/git-cherry-pick-pr-to-dev-branch.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)"/></a><div class="content"><a class="title" href="/2025/07/11/git-cherry-pick-pr-to-dev-branch/" title="Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)">Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)</a><time datetime="2025-07-11T08:30:00.000Z" title="发表于 2025-07-11 16:30:00">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/" title="Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查"><img src="/images/cover/hexo-butterfly-pr-git-troubleshooting-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查"/></a><div class="content"><a class="title" href="/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/" title="Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查">Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查</a><time datetime="2025-07-11T02:55:00.000Z" title="发表于 2025-07-11 10:55:00">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/09/hexo-butterfly-cover-image-debug-story/" title="一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录"><img src="/images/cover/hexo-butterfly-cover-image-debug-story.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录"/></a><div class="content"><a class="title" href="/2025/07/09/hexo-butterfly-cover-image-debug-story/" title="一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录">一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录</a><time datetime="2025-07-09T07:45:00.000Z" title="发表于 2025-07-09 15:45:00">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/07/hexo-butterfly-subtitle-debug-guide/" title="Hexo Butterfly 主题副标题不显示问题排查与解决"><img src="/images/cover/hexo-butterfly-subtitle-debug-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo Butterfly 主题副标题不显示问题排查与解决"/></a><div class="content"><a class="title" href="/2025/07/07/hexo-butterfly-subtitle-debug-guide/" title="Hexo Butterfly 主题副标题不显示问题排查与解决">Hexo Butterfly 主题副标题不显示问题排查与解决</a><time datetime="2025-07-07T08:30:00.000Z" title="发表于 2025-07-07 16:30:00">2025-07-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/cover/git-cherry-pick-pr-to-dev-branch.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By he0xwhale</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'he0xwhale/ai_blog',
      'data-repo-id': 'R_kgDOOy_oHw',
      'data-category-id': 'DIC_kwDOOy_oH84CrUlf',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>