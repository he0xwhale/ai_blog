<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AI WHALE</title>
  
  
  <link href="https://ai.he0xwhale.xyz/atom.xml" rel="self"/>
  
  <link href="https://ai.he0xwhale.xyz/"/>
  <updated>2025-07-11T08:24:14.248Z</updated>
  <id>https://ai.he0xwhale.xyz/</id>
  
  <author>
    <name>he0xwhale</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 技巧：如何将 Pull Request 的提交内容同步到开发分支 (使用 cherry-pick)</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/11/git-cherry-pick-pr-to-dev-branch/</id>
    <published>2025-07-11T08:30:00.000Z</published>
    <updated>2025-07-11T08:24:14.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在参与开源项目或团队协作时，我们通常会从一个开发分支（如 <code>dev</code> 或 <code>develop</code>）拉取一个特性分支进行开发，完成功能或 Bug 修复后，向主分支（如 <code>main</code> 或 <code>master</code>）提交 Pull Request (PR)。一旦 PR 被合并，我们的修改就进入了主分支。</p><p>然而，有时我们希望将 PR 的内容也同步回我们的开发分支（例如 <code>dev</code> 分支），以便本地开发环境保持最新，或者将该修改作为后续开发的基础。本文将详细介绍如何使用 Git 的 <code>cherry-pick</code> 命令来实现这一目标，并分享我在实际操作中遇到的问题及解决方案。</p><h2 id="什么是-git-cherry-pick？"><a href="#什么是-git-cherry-pick？" class="headerlink" title="什么是 git cherry-pick？"></a>什么是 <code>git cherry-pick</code>？</h2><p><code>git cherry-pick</code> 命令的作用是将一个或多个现有提交应用到当前分支。它会复制指定提交的更改，并在当前分支上创建一个新的提交。这与 <code>git merge</code> 或 <code>git rebase</code> 不同，<code>cherry-pick</code> 只挑选特定的提交，而不是合并整个分支的历史。</p><p><strong>适用场景：</strong></p><ul><li>将其他分支的单个或少量提交合并到当前分支。</li><li>将已合并到主分支的 PR 提交，同步回开发分支。</li><li>从一个特性分支中挑选出部分提交，应用到另一个特性分支。</li></ul><h2 id="操作步骤：将-PR-提交同步到-dev-分支"><a href="#操作步骤：将-PR-提交同步到-dev-分支" class="headerlink" title="操作步骤：将 PR 提交同步到 dev 分支"></a>操作步骤：将 PR 提交同步到 <code>dev</code> 分支</h2><p>假设您已经将 <code>fix-page-cover</code> 分支上的 Bug 修复提交到了官方仓库，并且现在希望将这个修复也应用到您的本地 <code>dev</code> 分支。</p><h3 id="1-确认当前分支"><a href="#1-确认当前分支" class="headerlink" title="1. 确认当前分支"></a>1. 确认当前分支</h3><p>首先，确保您当前位于目标分支，即您希望应用 PR 提交的分支（例如 <code>dev</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不在 dev 分支，切换到 dev</span></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><h3 id="2-查找-PR-提交的-SHA-值"><a href="#2-查找-PR-提交的-SHA-值" class="headerlink" title="2. 查找 PR 提交的 SHA 值"></a>2. 查找 PR 提交的 SHA 值</h3><p>您需要找到包含您 PR 内容的那个提交的 SHA 值。如果您是在一个专门的特性分支上完成的 PR，那么这个提交通常是该特性分支的最后一个提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 fix-page-cover 分支的提交历史</span></span><br><span class="line"><span class="comment"># 找到包含 PR 内容的提交（通常是您为 PR 编写的 commit message）</span></span><br><span class="line">git <span class="built_in">log</span> --oneline fix-page-cover</span><br></pre></td></tr></table></figure><p>例如，您可能会看到类似这样的输出：<br><code>8ae23cf Fix: Display cover images for categories and tags pages</code><br>这里的 <code>8ae23cf</code> 就是您需要的提交 SHA 值。</p><h3 id="3-执行-git-cherry-pick"><a href="#3-执行-git-cherry-pick" class="headerlink" title="3. 执行 git cherry-pick"></a>3. 执行 <code>git cherry-pick</code></h3><p>现在，在您的 <code>dev</code> 分支上执行 <code>cherry-pick</code> 命令，将找到的提交应用过来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 dev 分支上执行</span></span><br><span class="line">git cherry-pick &lt;提交的 SHA 值&gt;</span><br><span class="line"><span class="comment"># 例如：git cherry-pick 8ae23cf</span></span><br></pre></td></tr></table></figure><p>如果一切顺利，Git 会将该提交的更改应用到您的 <code>dev</code> 分支，并创建一个新的提交。</p><h2 id="常见问题及排查"><a href="#常见问题及排查" class="headerlink" title="常见问题及排查"></a>常见问题及排查</h2><p>在 <code>cherry-pick</code> 过程中，您可能会遇到一些问题。</p><h3 id="问题场景-1：git-log-提示“有歧义的参数”或“路径未匹配任何-git-已知文件”"><a href="#问题场景-1：git-log-提示“有歧义的参数”或“路径未匹配任何-git-已知文件”" class="headerlink" title="问题场景 1：git log 提示“有歧义的参数”或“路径未匹配任何 git 已知文件”"></a>问题场景 1：<code>git log</code> 提示“有歧义的参数”或“路径未匹配任何 git 已知文件”</h3><p><strong>问题描述</strong>：当您尝试使用 <code>git log --oneline &lt;branch&gt; &lt;file_path&gt;</code> 这样的命令来查找特定文件的提交历史时，Git 可能会报错。</p><p><strong>排查与解决</strong>：这是因为在 Git 命令中同时指定分支和文件路径时，需要使用 <code>--</code> 来明确分隔它们，以消除歧义。</p><ul><li><strong>解决方案</strong>：在文件路径前添加 <code>--</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline fix-page-cover -- themes/butterfly/layout/includes/header/index.pug</span><br></pre></td></tr></table></figure>如果您不确定具体的文件路径，或者只想查看整个分支的提交历史，可以直接使用 <code>git log --oneline &lt;branch&gt;</code>。</li></ul><h3 id="问题场景-2：git-cherry-pick-提示“无文件要提交，干净的工作区”-“空提交”"><a href="#问题场景-2：git-cherry-pick-提示“无文件要提交，干净的工作区”-“空提交”" class="headerlink" title="问题场景 2：git cherry-pick 提示“无文件要提交，干净的工作区” &#x2F; “空提交”"></a>问题场景 2：<code>git cherry-pick</code> 提示“无文件要提交，干净的工作区” &#x2F; “空提交”</h3><p><strong>问题描述</strong>：在执行 <code>git cherry-pick</code> 后，Git 提示“无文件要提交，干净的工作区”，并说明这是一个“空提交”。</p><p><strong>排查与解决</strong>：这表明您当前分支的工作区已经包含了要 <code>cherry-pick</code> 的提交所引入的所有修改。Git 发现当前分支的文件内容与目标提交的修改是相同的，因此没有实际的更改需要应用，从而生成了一个空提交。</p><ul><li><strong>解决方案</strong>：由于没有实际的修改，您可以直接跳过这个空提交，结束 <code>cherry-pick</code> 进程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --skip</span><br></pre></td></tr></table></figure>这通常意味着您之前已经通过其他方式（例如手动复制粘贴，或者更早的 <code>cherry-pick</code> 操作）将这些修改应用到了当前分支。</li></ul><h3 id="问题场景-3：git-push-提示“无效引用：upstream-dev”"><a href="#问题场景-3：git-push-提示“无效引用：upstream-dev”" class="headerlink" title="问题场景 3：git push 提示“无效引用：upstream&#x2F;dev”"></a>问题场景 3：<code>git push</code> 提示“无效引用：upstream&#x2F;dev”</h3><p><strong>问题描述</strong>：当您尝试从 <code>upstream</code> 远程仓库检出文件时（例如 <code>git checkout upstream/dev -- &lt;file&gt;</code>），Git 提示“无效引用：upstream&#x2F;dev”。</p><p><strong>排查与解决</strong>：这表明您的本地仓库还没有从 <code>upstream</code> 远程仓库抓取最新的分支信息。</p><ul><li><strong>解决方案</strong>：先执行 <code>git fetch upstream</code> 命令，将 <code>upstream</code> 远程仓库的所有分支信息同步到本地。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure>然后再次尝试 <code>git checkout upstream/dev -- &lt;file&gt;</code>。</li></ul><h3 id="问题场景-4：git-push-提示“无法推送一些引用到…”-例如-error-源引用规格-dev-没有匹配"><a href="#问题场景-4：git-push-提示“无法推送一些引用到…”-例如-error-源引用规格-dev-没有匹配" class="headerlink" title="问题场景 4：git push 提示“无法推送一些引用到…” (例如 error: 源引用规格 dev 没有匹配)"></a>问题场景 4：<code>git push</code> 提示“无法推送一些引用到…” (例如 <code>error: 源引用规格 dev 没有匹配</code>)</h3><p><strong>问题描述</strong>：在主仓库执行 <code>git push</code> 时，提示与分支引用相关的错误。</p><p><strong>排查与解决</strong>：这通常是因为您本地仓库的当前分支与远程仓库的期望分支不匹配，或者远程仓库没有您尝试推送的那个分支。</p><ul><li><strong>解决方案</strong>：<ol><li><strong>确认当前分支</strong>：使用 <code>git branch</code> 确认您当前所在的分支。</li><li><strong>确认远程仓库的分支结构</strong>：使用 <code>git remote show origin</code> 查看 <code>origin</code> 远程仓库的 HEAD 分支和已跟踪的分支。</li><li><strong>匹配推送目标</strong>：确保您 <code>git push</code> 的本地分支与远程目标分支是匹配的。例如，如果您的主仓库默认分支是 <code>main</code>，而您尝试推送到 <code>dev</code>，就会报错。您需要将 <code>git push origin dev</code> 修改为 <code>git push origin main</code>（或您实际的主分支名）。</li><li><strong>第一次推送新分支</strong>：如果您是第一次将本地分支推送到远程，需要使用 <code>-u</code> 参数设置上游跟踪：<code>git push -u origin &lt;branch_name&gt;</code>。</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>git cherry-pick</code> 是一个非常实用的 Git 命令，可以帮助我们在复杂的协作流程中精确地管理提交。通过本文的介绍，您应该能够掌握如何将 Pull Request 的提交内容同步到开发分支，并解决过程中可能遇到的一些常见 Git 问题。熟练运用这些 Git 技巧，将使您的开发流程更加顺畅高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在参与开源项目或团队协作时，我们通常会从一个开发分支（如 &lt;code&gt;dev&lt;/code&gt; 或 &lt;code&gt;develop&lt;/code&gt;）拉</summary>
      
    
    
    
    <category term="技术分享" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="Git实践" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Git%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="踩坑记录" scheme="https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Git" scheme="https://ai.he0xwhale.xyz/tags/Git/"/>
    
    <category term="GitHub" scheme="https://ai.he0xwhale.xyz/tags/GitHub/"/>
    
    <category term="Pull Request" scheme="https://ai.he0xwhale.xyz/tags/Pull-Request/"/>
    
    <category term="cherry-pick" scheme="https://ai.he0xwhale.xyz/tags/cherry-pick/"/>
    
    <category term="分支管理" scheme="https://ai.he0xwhale.xyz/tags/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 主题 Pull Request 过程中的 Git 实践与常见问题排查</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/11/hexo-butterfly-pr-git-troubleshooting-guide/</id>
    <published>2025-07-11T02:55:00.000Z</published>
    <updated>2025-07-11T07:35:00.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是关于向 Hexo Butterfly 主题提交 Pull Request 过程中，我所经历的 Git 实践流程，以及期间遇到的典型问题和解决方案的总结。</p></blockquote><hr><h3 id="📌-重要注意事项"><a href="#📌-重要注意事项" class="headerlink" title="📌 重要注意事项"></a><strong>📌 重要注意事项</strong></h3><p>本次 Pull Request 的出发点是解决一个关于 Hexo Butterfly 主题分类页和标签页封面图不显示的问题。在 PR 过程中，我得到了主题作者的反馈，这修正了我对 <code>themes/butterfly/_config.yml</code> 中 <code>category_img</code> 和 <code>tag_img</code> 配置项的理解。</p><p><strong>核心 Bug 根源的修正理解：</strong></p><ul><li><strong>最初的误解</strong>：我曾认为 <code>category_img</code> 和 <code>tag_img</code> 是用于设置分类页 <code>/categories/</code> 和标签页 <code>/tags/</code> 主页的封面图。</li><li><strong>正确的理解</strong>：<code>category_img</code> 和 <code>tag_img</code> 实际上是为<strong>文章</strong>（posts）在分类&#x2F;标签归档页面中提供一个<strong>备用</strong>的封面图。而分类页 <code>/categories/</code> 和标签页 <code>/tags/</code> 的主封面图，应该在它们各自的 Markdown 文件（例如 <code>source/categories/index.md</code> 和 <code>source/tags/index.md</code>）的 Front-matter 中通过 <code>top_img</code> 属性来配置。</li></ul><p><strong>尽管如此，本文后续提及的 Git 操作和问题排查经验仍然是通用的，且本文中涉及到的 Pug 模板代码修正（已在 PR 中提交）也完善了主题的逻辑，使其能更灵活地处理这些页面类型。</strong></p><p>关于这个 Bug 问题的详细调试过程、代码修正细节以及对 <code>tag_img</code> 和 <code>category_img</code> 作用的更详细解释，请参阅我的另一篇文章：<a href="/2025/07/09/hexo-butterfly-cover-image-debug-story/">《一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录》</a>。</p><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>参与开源项目贡献是提升技术能力、回馈社区的绝佳方式。然而，对于初次接触或不熟悉 Git&#x2F;GitHub 工作流的朋友来说，其中的一些操作细节可能会成为不小的挑战。本文将以我向 Hexo Butterfly 主题提交 Pull Request 的亲身经历为例，分享一套实用的 Git 实践流程，并着重梳理了我在过程中遇到的常见问题及其排查与解决之道。</p><h2 id="PR-背景与核心问题简述"><a href="#PR-背景与核心问题简述" class="headerlink" title="PR 背景与核心问题简述"></a>PR 背景与核心问题简述</h2><p>本次 Pull Request 的背景是解决 Hexo Butterfly 主题中一个关于分类页和标签页封面图显示的问题。尽管后来发现对 <code>tag_img</code> 和 <code>category_img</code> 的配置用途存在误解，但对 Pug 模板的修正（已提交 PR）仍然是有效的，它优化了主题在处理这些页面类型时的逻辑。</p><p><strong>关于 Bug 详情、代码修正和关键解决方案（Hexo 缓存问题）</strong>：请参阅 <a href="/2025/07/09/hexo-butterfly-cover-image-debug-story/">《一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录》</a>。</p><h2 id="Hexo-Butterfly-主题-Pull-Request-实践流程"><a href="#Hexo-Butterfly-主题-Pull-Request-实践流程" class="headerlink" title="Hexo Butterfly 主题 Pull Request 实践流程"></a>Hexo Butterfly 主题 Pull Request 实践流程</h2><p>以下是我向 Hexo Butterfly 主题提交 Pull Request 的具体操作步骤，这是一个推荐的、能够保持提交纯净的流程。</p><h3 id="1-Fork-官方仓库并克隆到本地"><a href="#1-Fork-官方仓库并克隆到本地" class="headerlink" title="1. Fork 官方仓库并克隆到本地"></a>1. Fork 官方仓库并克隆到本地</h3><p>首先，在 GitHub 上将官方的 <code>jerryc127/hexo-theme-butterfly</code> 仓库 Fork 到您自己的账户下（例如 <code>he0xwhale/hexo-theme-butterfly</code>）。然后，将您 Fork 后的仓库克隆到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆您 Fork 后的仓库到本地</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/he0xwhale/hexo-theme-butterfly.git</span><br><span class="line"><span class="built_in">cd</span> hexo-theme-butterfly <span class="comment"># 进入主题目录</span></span><br></pre></td></tr></table></figure><h3 id="2-创建并切换到新的修复分支"><a href="#2-创建并切换到新的修复分支" class="headerlink" title="2. 创建并切换到新的修复分支"></a>2. 创建并切换到新的修复分支</h3><p>为了保持主分支的整洁，并方便管理不同的功能或修复，我们应该为每次贡献创建一个新的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于当前分支（通常是 dev 或 master）创建并切换到新分支</span></span><br><span class="line">git checkout -b fix-page-cover</span><br></pre></td></tr></table></figure><h3 id="3-进行代码修改"><a href="#3-进行代码修改" class="headerlink" title="3. 进行代码修改"></a>3. 进行代码修改</h3><p>在新的分支上进行您需要的代码修改。对于本次 PR，关键的修改位于 <a href="themes/butterfly/layout/includes/header/index.pug"><code>themes/butterfly/layout/includes/header/index.pug</code></a>。</p><h3 id="4-精确暂存并提交代码"><a href="#4-精确暂存并提交代码" class="headerlink" title="4. 精确暂存并提交代码"></a>4. 精确暂存并提交代码</h3><p>完成代码修改后，我们需要将修改添加到 Git 的暂存区，并创建一个提交。<strong>关键在于只添加您希望贡献的文件，避免混入个人配置。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只将对 index.pug 的修改添加到暂存区</span></span><br><span class="line">git add layout/includes/header/index.pug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交修改，附上清晰的提交信息</span></span><br><span class="line">git commit -m <span class="string">&quot;Fix: Display cover images for categories and tags pages&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-推送分支到您的-Fork-仓库"><a href="#5-推送分支到您的-Fork-仓库" class="headerlink" title="5. 推送分支到您的 Fork 仓库"></a>5. 推送分支到您的 Fork 仓库</h3><p>现在，将包含您修改的新分支推送到您在 GitHub 上的 Fork 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送分支到自己的远程仓库</span></span><br><span class="line">git push origin fix-page-cover</span><br></pre></td></tr></table></figure><h3 id="6-在-GitHub-上创建-Pull-Request"><a href="#6-在-GitHub-上创建-Pull-Request" class="headerlink" title="6. 在 GitHub 上创建 Pull Request"></a>6. 在 GitHub 上创建 Pull Request</h3><p>当您成功推送分支后，访问您 Fork 仓库的 GitHub 页面，或者直接使用 <code>git push</code> 输出中提供的链接，创建 Pull Request。</p><ul><li><strong>填写 PR 信息</strong>：提供清晰的标题和详细的描述，解释您解决了什么问题，为什么重要，如何复现，以及您的解决方案。</li></ul><h2 id="Pull-Request-过程中遇到的典型问题及排查"><a href="#Pull-Request-过程中遇到的典型问题及排查" class="headerlink" title="Pull Request 过程中遇到的典型问题及排查"></a>Pull Request 过程中遇到的典型问题及排查</h2><p>在上述流程中，我遇到了一些常见的 Git 问题，以下是我当时的排查过程和最终解决方案。</p><h3 id="问题场景-1：git-commit-失败-“无文件要提交，干净的工作区”"><a href="#问题场景-1：git-commit-失败-“无文件要提交，干净的工作区”" class="headerlink" title="问题场景 1：git commit 失败 (“无文件要提交，干净的工作区”)"></a>问题场景 1：<code>git commit</code> 失败 (“无文件要提交，干净的工作区”)</h3><p><strong>问题描述</strong>：在执行 <code>git add</code> 之后尝试 <code>git commit</code>，但 Git 提示“无文件要提交，干净的工作区”。这表明尽管我执行了 <code>git add</code>，但实际上并没有任何修改被暂存。</p><p><strong>排查与解决</strong>：这通常发生在您在 <code>git add</code> 之前，工作区已经被其他操作（例如 <code>git stash</code>）清空了修改。</p><ul><li><strong>解决方案</strong>：首先确认工作区是否有您需要的修改（<code>git status</code>）。如果修改被 <code>stash</code> 了，需要先 <code>git stash pop</code> 恢复。然后重新 <code>git add</code> 目标文件，再 <code>git commit</code>。</li></ul><h3 id="问题场景-2：git-push-权限被拒绝-403-Forbidden"><a href="#问题场景-2：git-push-权限被拒绝-403-Forbidden" class="headerlink" title="问题场景 2：git push 权限被拒绝 (403 Forbidden)"></a>问题场景 2：<code>git push</code> 权限被拒绝 (403 Forbidden)</h3><p><strong>问题描述</strong>：在尝试将本地分支推送到远程仓库时，Git 提示 <code>remote: Permission denied</code> 和 <code>403 Forbidden</code> 错误。</p><p><strong>排查与解决</strong>：这是因为本地仓库的 <code>origin</code> 远程地址指向了您没有推送权限的仓库（例如官方仓库）。</p><ul><li><strong>解决方案</strong>：将本地 <code>origin</code> 远程地址修改为自己 Fork 后的仓库地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 themes/butterfly 目录下执行</span></span><br><span class="line">git remote set-url origin https://github.com/he0xwhale/hexo-theme-butterfly.git</span><br></pre></td></tr></table></figure>（请将 <code>he0xwhale</code> 替换为您的 GitHub 用户名）</li></ul><h3 id="问题场景-3：git-push-提示“仓库未找到”-Repository-not-found"><a href="#问题场景-3：git-push-提示“仓库未找到”-Repository-not-found" class="headerlink" title="问题场景 3：git push 提示“仓库未找到” (Repository not found)"></a>问题场景 3：<code>git push</code> 提示“仓库未找到” (<code>Repository not found</code>)</h3><p><strong>问题描述</strong>：在更新了 <code>origin</code> 地址并尝试 <code>git push</code> 后，Git 提示 <code>fatal: 仓库 &#39;https://github.com/he0xwhale/hexo-theme-butterfly.git/&#39; 未找到</code>。</p><p><strong>排查与解决</strong>：这表明您在 <code>git remote set-url</code> 中指定的 URL 对应的仓库在 GitHub 上不存在。这通常意味着您还没有成功地 Fork 官方仓库。</p><ul><li><strong>解决方案</strong>：请访问官方 Butterfly 主题的 GitHub 页面 (<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>)，然后点击页面右上角的 <strong>“Fork”</strong> 按钮，在您的 GitHub 账户下创建一个副本。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>向开源项目贡献代码是一个充满挑战但也极具成就感的过程。通过解决实际问题，并遵循标准的 Git&#x2F;GitHub 流程，我们不仅提升了自身的技术能力，也为社区贡献了一份力量。希望本文总结的这些常见问题和解决方案，能为您在开源贡献的道路上提供一些帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是关于向 Hexo Butterfly 主题提交 Pull Request 过程中，我所经历的 Git 实践流程，以及期间遇到的典型问题和解决方案的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;📌-重要注意事项&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="Git实践" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/Git%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="踩坑记录" scheme="https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Git" scheme="https://ai.he0xwhale.xyz/tags/Git/"/>
    
    <category term="Butterfly" scheme="https://ai.he0xwhale.xyz/tags/Butterfly/"/>
    
    <category term="GitHub" scheme="https://ai.he0xwhale.xyz/tags/GitHub/"/>
    
    <category term="Pull Request" scheme="https://ai.he0xwhale.xyz/tags/Pull-Request/"/>
    
    <category term="问题排查" scheme="https://ai.he0xwhale.xyz/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>一次因缓存引发的“灵异事件”：Hexo Butterfly 主题封面图调试全记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/09/hexo-butterfly-cover-image-debug-story/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/09/hexo-butterfly-cover-image-debug-story/</id>
    <published>2025-07-09T07:45:00.000Z</published>
    <updated>2025-07-11T07:37:12.402Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在搭建和美化 Hexo 博客的过程中，我们时常会遇到一些看似简单，却足以让人抓狂的“灵异事件”。最近，我就和我的 AI 助手 Roo 经历了一次这样的封面图调试之旅。一个简单的图片不显示问题，我们排查了代码、配置、路径，甚至怀疑人生，最终却发现“真凶”隐藏在一个意想不到的地方。</p></blockquote><p>这篇文章记录了我们完整的调试过程，希望能为同样在 Hexo 世界中探索的你提供一些有价值的参考和避坑指南。</p><hr><h3 id="📌-重要更新与注意事项（2025-07-11）"><a href="#📌-重要更新与注意事项（2025-07-11）" class="headerlink" title="📌 重要更新与注意事项（2025-07-11）"></a><strong>📌 重要更新与注意事项（2025-07-11）</strong></h3><p>在 Pull Request 中，我得到了主题作者的反馈，这修正了我对 <code>themes/butterfly/_config.yml</code> 中 <code>category_img</code> 和 <code>tag_img</code> 配置项的理解。</p><p><strong>最初的误解：</strong> 本文最初的问题提出（“不听话的 <code>category_img</code> 和 <code>tag_img</code>”）是基于一个误解，认为 <code>category_img</code> 和 <code>tag_img</code> 是用于设置分类页 <code>/categories/</code> 和标签页 <code>/tags/</code> 主页的封面图。</p><p><strong>正确的理解：</strong></p><ul><li><code>category_img</code> 和 <code>tag_img</code> 配置项，实际上是用于设置<strong>当文章没有指定 <code>cover</code> 时，其所属分类或标签页的</strong>默认封面图。换句话说，它们是为<strong>文章</strong>（posts）在分类&#x2F;标签归档页面中提供一个备用的封面图，而不是为 <code>/categories/</code> 或 <code>/tags/</code> 这些<strong>主归档页面</strong>设置封面。</li><li><strong>分类页 <code>/categories/</code> 和标签页 <code>/tags/</code> 的主封面图，应该在它们各自的 Markdown 文件（例如 <code>source/categories/index.md</code> 和 <code>source/tags/index.md</code>）的 Front-matter 中通过 <code>top_img</code> 属性来配置。</strong></li></ul><hr><h3 id="一、问题的提出：对-category-img-和-tag-img-的误解"><a href="#一、问题的提出：对-category-img-和-tag-img-的误解" class="headerlink" title="一、问题的提出：对 category_img 和 tag_img 的误解"></a>一、问题的提出：对 <code>category_img</code> 和 <code>tag_img</code> 的误解</h3><p>最初的问题很简单：我为分类页和标签页设置了封面图，但它们就是不显示。</p><p>在 <code>themes/butterfly/_config.yml</code> 中，我的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># If the banner of page not setting, it will show the default_top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> category page, not categories page</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">/images/website/categories.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> tag page, not tags page</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">/images/website/tag.png</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>奇怪的是，如果我设置了 <code>default_top_img</code>，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_top_img:</span> <span class="string">/images/website/bg.png</span></span><br></pre></td></tr></table></figure><p>那么分类页和标签页就会显示 <code>bg.png</code> 这张图片。这说明页面本身能够显示封面图，但 <code>category_img</code> 和 <code>tag_img</code> 这两个配置项被无视了。</p><h3 id="二、初步排查：代码逻辑的“完美无缺”"><a href="#二、初步排查：代码逻辑的“完美无缺”" class="headerlink" title="二、初步排查：代码逻辑的“完美无缺”"></a>二、初步排查：代码逻辑的“完美无缺”</h3><p>我们首先进行了一系列常规的代码层面排查：</p><ol><li><strong>检查文件是否存在</strong>：确认 <code>/source/images/website/categories.png</code> 和 <code>/source/images/website/tag.png</code> 这两个图片文件确实存在。</li><li><strong>检查模板逻辑</strong>：我们深入分析了 Butterfly 主题的核心模板文件 <code>themes/butterfly/layout/includes/header/index.pug</code>。通过分析，我们确定了封面图的渲染逻辑。</li><li><strong>调试页面变量</strong>：通过在模板中输出调试信息，我们发现了一个关键信息：在分类页（<code>/categories/</code>），Hexo 传递给模板的变量 <code>page.type</code> 的值是 <code>categories</code>，但主题内部计算出的 <code>globalPageType</code> 却是 <code>page</code>。</li></ol><p>基于这个发现，我们修正了 <code>header/index.pug</code> 的代码，在 <code>case globalPageType</code> 的 <code>when &#39;page&#39;</code> 分支中，增加了对 <code>page.type</code> 的判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// themes/butterfly/layout/includes/header/index.pug</span><br><span class="line">// ...</span><br><span class="line">    when &#x27;page&#x27;</span><br><span class="line">      if page.type === &#x27;categories&#x27;</span><br><span class="line">        - top_img = returnTopImg(theme.category_img)</span><br><span class="line">      else if page.type === &#x27;tags&#x27;</span><br><span class="line">        - top_img = returnTopImg(theme.tag_img)</span><br><span class="line">      else</span><br><span class="line">        - top_img = page.top_img || theme.default_top_img</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>这段代码的逻辑非常清晰：当页面类型是 <code>page</code> 时，再检查其具体的 <code>type</code> 属性，如果是 <code>categories</code> 或 <code>tags</code>，就使用对应的图片。</p><p>至此，我们确信代码逻辑已经完美。</p><h3 id="三、陷入僵局：当-hexo-clean-也不管用时"><a href="#三、陷入僵局：当-hexo-clean-也不管用时" class="headerlink" title="三、陷入僵局：当 hexo clean 也不管用时"></a>三、陷入僵局：当 <code>hexo clean</code> 也不管用时</h3><p>然而，最诡异的事情发生了。尽管我们每次修改后都严格执行了 <code>hexo clean</code> 来清除缓存，并使用 <code>Ctrl+Shift+R</code> 硬刷新浏览器，但问题依旧。图片依然不显示，就好像我们的代码修改从未发生过一样。</p><p>这让我们一度怀疑是 Pug 模板引擎的渲染问题，甚至尝试了用 JavaScript 动态修改 <code>style</code> 属性等各种“曲线救国”的方法，但都无济于事。</p><h3 id="四、最终突破：重启-hexo-server-后的“豁然开朗”"><a href="#四、最终突破：重启-hexo-server-后的“豁然开朗”" class="headerlink" title="四、最终突破：重启 hexo server 后的“豁然开朗”"></a>四、最终突破：重启 <code>hexo server</code> 后的“豁然开朗”</h3><p>就在我们几乎要放弃的时候，转机出现了。<del>第二天，我重启了电脑，</del>再次运行 <code>hexo server</code>，然后惊奇地发现——一切都正常了！分类页和标签页的封面图都正确地显示了出来。</p><p><strong>这让我们最终定位到了问题的根本原因：Hexo 渲染进程的陈旧缓存。</strong></p><p>经过后续的验证，我们发现之前的代码修改是完全正确的，只是需要<strong>彻底重启 <code>hexo server</code> 服务</strong>才能让新的模板逻辑生效。</p><ul><li><strong><code>hexo clean</code> 的局限性</strong>：这个命令确实可以清除 <code>public</code> 目录和物理的 <code>db.json</code> 缓存文件。但是，它<strong>无法重置正在运行的 <code>hexo server</code> 进程的内存状态</strong>。</li><li><strong><code>hexo server</code> 的“幽灵”状态</strong>：在我们长时间、高强度的调试过程中，对主题的模板文件 (<code>.pug</code>) 和辅助函数 (<code>.js</code>) 进行了大量修改。这很可能导致了 <code>hexo server</code> 的 Node.js 进程内部状态变得不一致。它可能没有完全重新加载所有模块，或者某些变量的缓存在内存中没有被正确清除。</li><li><strong>重启的威力</strong>：<del>重启电脑彻底终止了所有进程，包括那个可能已经“精神错乱”的 <code>hexo server</code> 进程。</del> <strong>停止并重启 <code>hexo server</code></strong> 会终结旧的 Node.js 进程。当我们再次启动服务时，一个全新的、干净的进程会加载所有最新的、正确的代码和配置，问题自然就迎刃而解了。</li></ul><h3 id="五、经验总结与操作建议"><a href="#五、经验总结与操作建议" class="headerlink" title="五、经验总结与操作建议"></a>五、经验总结与操作建议</h3><p>这次漫长而曲折的调试过程，给我们带来了宝贵的经验：</p><ol><li><strong>养成 <code>hexo clean</code> 的好习惯</strong>：在修改任何配置或代码后，执行 <code>hexo clean</code> 永远是第一选择。</li><li><strong>重启 <code>hexo server</code> 是必要的</strong>：当你修改了主题的 <code>.js</code> 逻辑文件或 <code>.pug</code> 模板文件后，如果 <code>hexo clean</code> 不起作用，请务必<strong>停止 (<code>Ctrl+C</code>) 并重新启动 <code>hexo server</code></strong>。这会强制 Hexo 加载一个全新的、干净的运行环境。</li><li><strong>浏览器缓存不可忽视</strong>：在开发时，善用 <code>Ctrl+Shift+R</code> 硬刷新或在开发者工具中禁用缓存。</li><li><strong>页面封面图的正确设置</strong>：<ul><li><strong>独立页面（如“关于”、“友链”）</strong>：在对应的 Markdown 文件 (<code>source/about/index.md</code>, <code>source/friends/index.md</code>) 的 <strong>Front-matter</strong> 中添加 <code>top_img</code> 属性来单独指定封面图。</li><li><strong>分类页 <code>/categories/</code> 和标签页 <code>/tags/</code> 主页</strong>：同独立页面一样，在各自的 Markdown 文件 (<code>source/categories/index.md</code>, <code>source/tags/index.md</code>) 的 <strong>Front-matter</strong> 中通过 <code>top_img</code> 属性来配置。</li><li><strong><code>_config.yml</code> 中的 <code>category_img</code> 和 <code>tag_img</code></strong>：这些配置项是为<strong>文章</strong>（posts）在其所属分类或标签归档页面中提供一个<strong>备用</strong>的封面图，而不是为 <code>/categories/</code> 或 <code>/tags/</code> 主页设置封面。</li></ul></li></ol><p>希望这次的“灵异事件”记录，能帮助你在 Hexo 的世界里少走一些弯路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在搭建和美化 Hexo 博客的过程中，我们时常会遇到一些看似简单，却足以让人抓狂的“灵异事件”。最近，我就和我的 AI 助手 Roo 经历了一次这样的封面图调试之旅。一个简单的图片不显示问题，我们排查了代码、配置、路径，甚至怀疑人生，最终却发现“真</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="问题排查" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="踩坑记录" scheme="https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
    <category term="前端调试" scheme="https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
    <category term="Debugging" scheme="https://ai.he0xwhale.xyz/tags/Debugging/"/>
    
    <category term="Butterfly" scheme="https://ai.he0xwhale.xyz/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 主题副标题不显示问题排查与解决</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/07/hexo-butterfly-subtitle-debug-guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/07/hexo-butterfly-subtitle-debug-guide/</id>
    <published>2025-07-07T08:30:00.000Z</published>
    <updated>2025-07-09T07:53:21.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在使用 Hexo 搭建博客并采用 Butterfly 主题时，您可能会遇到一个令人困惑的问题：网站的 <code>&lt;title&gt;</code> 标签中正确显示了站点标题和副标题（例如 “AI whale - Exploring the World of AI”），但在实际的页面内容（尤其是首页的头部区域）中，却只显示了站点标题，而副标题神秘“失踪”了。本文将详细记录这一问题的排查过程，并提供最终的解决方案。</p><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>在浏览器中检查网站首页的 HTML 元素，可以发现 <code>&lt;head&gt;</code> 标签内的 <code>&lt;title&gt;</code> 元素内容是完整的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>AI whale - Exploring the World of AI<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，在 <code>&lt;body&gt;</code> 内部的可见区域，例如 <code>&lt;header&gt;</code> 部分，却只有主标题“AI whale”显示，副标题“Exploring the World of AI”不见踪影。</p><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol><li><p><strong>检查全局配置 (<code>_config.yml</code>)</strong><br>首先，我们检查了 Hexo 的全局配置文件 <code>_config.yml</code>，确认 <code>title</code> 和 <code>subtitle</code> 配置项都已正确设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">AI</span> <span class="string">whale</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&quot;Exploring the World of AI&quot;</span></span><br></pre></td></tr></table></figure><p>这表明网站的元信息是正确的，问题可能出在主题的渲染逻辑上。</p></li><li><p><strong>定位主题配置文件 (<code>themes/butterfly/_config.yml</code>)</strong><br>Hexo 主题通常有自己的配置文件，这些配置会覆盖或合并全局配置。对于 Butterfly 主题，其配置文件位于 <code>themes/butterfly/_config.yml</code>。我们检查了该文件，发现了 <code>subtitle</code> 相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># themes/butterfly/_config.yml</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span> <span class="comment"># 启用打字机效果</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;从传统编程到AI编程，一刻不停的疲于奔命&quot;</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>这里注意到 <code>subtitle</code> 被定义为一个对象，其中 <code>enable</code> 为 <code>true</code>，并且 <code>sub</code> 数组中包含了另一个字符串，而不是全局 <code>_config.yml</code> 中的“Exploring the World of AI”。</p></li><li><p><strong>分析主题渲染逻辑 (<code>themes/butterfly/layout/includes/header/index.pug</code> 和 <code>themes/butterfly/layout/includes/third-party/subtitle.pug</code>)</strong><br>我们进一步深入主题的模板文件，发现主页头部渲染逻辑位于 <code>themes/butterfly/layout/includes/header/index.pug</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// themes/butterfly/layout/includes/header/index.pug</span><br><span class="line">// ...</span><br><span class="line">else if globalPageType === &#x27;home&#x27;</span><br><span class="line">  #site-info</span><br><span class="line">    h1#site-title=config.title</span><br><span class="line">    if theme.subtitle.enable // 条件判断</span><br><span class="line">      - var loadSubJs = true</span><br><span class="line">      #site-subtitle</span><br><span class="line">        span#subtitle // 副标题占位符</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>而 <code>span#subtitle</code> 的内容填充则是由 <code>themes/butterfly/layout/includes/third-party/subtitle.pug</code> 中的 JavaScript 动态完成的。关键在于该文件中的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// themes/butterfly/layout/includes/third-party/subtitle.pug</span><br><span class="line">- const &#123; effect, source, sub, typed_option &#125; = theme.subtitle</span><br><span class="line">// ...</span><br><span class="line">script.</span><br><span class="line">  window.typedJSFn = &#123;</span><br><span class="line">    init: str =&gt; &#123;</span><br><span class="line">      // ... (Typed.js 初始化逻辑)</span><br><span class="line">    &#125;,</span><br><span class="line">    run: subtitleType =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    processSubtitle: (content, extraContents = []) =&gt; &#123;</span><br><span class="line">      if (!&#123;effect&#125;) &#123; // 如果 effect 为 false，使用 Typed.js</span><br><span class="line">        // ...</span><br><span class="line">      &#125; else &#123; // 如果 effect 为 true，直接设置 textContent</span><br><span class="line">        document.getElementById(&#x27;subtitle&#x27;).textContent = typeof content === &#x27;string&#x27; ? content :</span><br><span class="line">          (Array.isArray(content) &amp;&amp; content.length &gt; 0 ? content[0] : &#x27;&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>我们发现，如果 <code>theme.subtitle.effect</code> 为 <code>true</code>，则会直接从 <code>theme.subtitle.sub</code> 数组中获取第一个元素作为副标题文本。</p></li><li><p><strong>发现配置冲突</strong><br>问题浮出水面：Hexo 在合并全局 <code>_config.yml</code> 和主题 <code>_config.butterfly.yml</code> 时，对于 <code>subtitle</code> 这个配置项，并没有进行深层合并 (deep merge)，而是简单地用全局 <code>_config.yml</code> 中 <code>subtitle</code> 的字符串值（”Exploring the World of AI”）覆盖了主题 <code>_config.butterfly.yml</code> 中 <code>subtitle</code> 的整个对象。</p><p>这意味着，当 Pug 模板尝试访问 <code>theme.subtitle.enable</code> 或 <code>theme.subtitle.sub</code> 时，它实际上是在尝试访问字符串 <code>&quot;Exploring the World of AI&quot;</code> 的属性，这必然导致 <code>undefined</code> 或错误。因此，<code>if theme.subtitle.enable</code> 条件始终为 <code>false</code>，导致副标题的 HTML 结构和 JavaScript 逻辑都没有被渲染到最终的 <code>public/index.html</code> 中。</p><p>通过在 Pug 模板中输出 <code>theme</code> 对象的完整 JSON 字符串，我们证实了这一点：<code>&quot;subtitle&quot;: &quot;Exploring the World of AI&quot;</code> 确实是 <code>theme</code> 对象中 <code>subtitle</code> 的实际值。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>根本原因是 Hexo 配置的合并机制。要解决此问题，需要确保主题的 <code>subtitle</code> 配置能够正确被解析。</p><p><strong>最直接的解决方案是：</strong></p><p>将 Hexo 全局配置文件 (<code>_config.yml</code>) 中的 <code>subtitle</code> 配置项移除或注释掉。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">AI</span> <span class="string">whale</span></span><br><span class="line"><span class="comment"># subtitle: &quot;Exploring the World of AI&quot; # 注释掉或删除此行</span></span><br></pre></td></tr></table></figure><p>通过这样做，Hexo 在生成静态文件时，将不再有全局的 <code>subtitle</code> 字符串来覆盖主题的 <code>subtitle</code> 对象。这样，主题 <code>themes/butterfly/_config.yml</code> 中定义的 <code>subtitle</code> 对象（包括 <code>enable: true</code> 和 <code>sub</code> 数组）就会被正确加载和使用，从而使得副标题能够正常显示。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次排查的核心在于理解 Hexo 配置文件的合并机制以及主题渲染逻辑对配置项的依赖。当全局配置与主题配置存在同名但不同类型（字符串 vs. 对象）的配置项时，Hexo 会优先使用全局配置，导致主题的复杂配置无法生效。通过移除冲突的全局配置，我们成功地让主题的副标题功能恢复正常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在使用 Hexo 搭建博客并采用 Butterfly 主题时，您可能会遇到一个令人困惑的问题：网站的 &lt;code&gt;&amp;lt;title&amp;gt;</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Debugging" scheme="https://ai.he0xwhale.xyz/tags/Debugging/"/>
    
    <category term="Butterfly" scheme="https://ai.he0xwhale.xyz/tags/Butterfly/"/>
    
    <category term="Configuration" scheme="https://ai.he0xwhale.xyz/tags/Configuration/"/>
    
    <category term="Front-end" scheme="https://ai.he0xwhale.xyz/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>Hexo多语言博客导航问题排查全记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/04/hexo-multilingual-guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/04/hexo-multilingual-guide/</id>
    <published>2025-07-04T03:00:00.000Z</published>
    <updated>2025-07-08T03:19:29.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文详细记录了在 Hexo 博客中使用 <code>hexo-multiple-language-generate</code> 插件对 Volantis 主题进行多语言国际化时遇到的各种问题，包括目录结构调整、配置文件适配、导航链接错误、样式冲突等，以及从初步尝试到最终放弃该方案的全过程。</p></blockquote><h3 id="国际化需求与初步方案"><a href="#国际化需求与初步方案" class="headerlink" title="国际化需求与初步方案"></a>国际化需求与初步方案</h3><p>我希望对现有 Hexo 博客进行国际化，支持中文（zh-CN）和英文（en）两种语言。初步方案是利用 <code>hexo-multiple-language-generate</code> 插件，并调整项目结构和配置文件。</p><p><strong>核心变动点：</strong></p><ol><li><strong>安装插件</strong>: <code>hexo-multiple-language-generate</code>。</li><li><strong>调整项目结构</strong>: 为每种语言创建独立的 <code>source</code> 目录（<code>source-zh/</code>、<code>source-en/</code>）。</li><li><strong>Hexo 配置文件</strong>: 为每种语言创建独立的 Hexo 配置文件（<code>config.zh.yml</code>、<code>config.en.yml</code>）。</li><li><strong>插件配置文件</strong>: 在项目根目录创建 <code>hexo-multiple-language.yml</code>。</li><li><strong>主题配置文件</strong>: 为每种语言创建独立的主题配置文件（<code>config.volantis.zh.yml</code>、<code>config.volantis.en.yml</code>）。</li><li><strong>使用新命令</strong>: 生成博客时使用 <code>hexo multiple-language-generate</code>。</li></ol><h3 id="阶段一：基础配置与内容迁移"><a href="#阶段一：基础配置与内容迁移" class="headerlink" title="阶段一：基础配置与内容迁移"></a>阶段一：基础配置与内容迁移</h3><p>按照初步方案，我安装了插件，创建了 <code>hexo-multiple-language.yml</code> 配置文件，并调整了目录结构，将中英文内容分别迁移到 <code>source-zh</code> 和 <code>source-en</code> 目录。为了确保英文站点有内容可以生成，我还在 <code>source-en/_posts/</code> 下手动创建了一篇英文测试文章 <code>hello-world-en.md</code>。</p><p>同时，我创建了 <code>config.zh.yml</code> 和 <code>config.en.yml</code>，分别配置了各自的语言、URL、源目录等信息，并确保 <code>public_dir</code> 指向统一的 <code>public</code> 目录，以便插件能正确地将英文内容生成到 <code>public/en/</code> 子目录下。</p><h3 id="阶段二：问题浮现与排查"><a href="#阶段二：问题浮现与排查" class="headerlink" title="阶段二：问题浮现与排查"></a>阶段二：问题浮现与排查</h3><p>完成基础配置并生成站点后，一系列问题开始出现。</p><h4 id="问题一：导航栏文字被挤压"><a href="#问题一：导航栏文字被挤压" class="headerlink" title="问题一：导航栏文字被挤压"></a>问题一：导航栏文字被挤压</h4><p>当我访问英文站点 <code>http://localhost:5000/en/</code> 时，导航栏上的链接文字被挤压，只显示图标。通过浏览器开发者工具发现，<code>&lt;a&gt;</code> 标签的 <code>display</code> 属性计算结果为 <code>block</code>。</p><ul><li><strong>尝试与解决</strong>: 起初尝试通过外部 CSS 文件覆盖样式，但未生效。最终，我直接修改了 <code>themes/volantis/layout/_partial/header.ejs</code>，在导航链接的 <code>&lt;a&gt;</code> 标签中添加行内样式 <code>style=&quot;display: inline-flex; align-items: center;&quot;</code>，成功解决了文字挤压问题。</li></ul><h4 id="问题二：导航链接错误"><a href="#问题二：导航链接错误" class="headerlink" title="问题二：导航链接错误"></a>问题二：导航链接错误</h4><p>这是最核心的问题。在 Volantis 主题的 Hexo 博客中，导航栏上的语言切换链接（“简体中文”和“English”）显示和跳转异常。</p><ul><li><p><strong>具体表现</strong>: 当访问英文文章页面（例如 <code>http://localhost:5000/en/hello-world-en/</code>）时，导航栏中的“简体中文”链接本应指向 <code>http://localhost:5000/</code>，却错误地指向了 <code>http://localhost:5000/en/</code>；而“English”链接本应指向 <code>http://localhost:5000/en/</code>，却错误地指向了 <code>http://localhost:5000/en/en/</code>。</p></li><li><p><strong>初步排查</strong>: 我检查了所有相关的配置文件：</p><ol><li><code>themes/volantis/layout/_partial/header.ejs</code>：确认了链接是通过 <code>&lt;%- url_for(value.url) %&gt;</code> 动态生成的。</li><li><code>_config.yml</code> 和 <code>config.*.yml</code>：确认了多语言和永久链接的设置。</li><li><code>config.volantis.*.yml</code>：确认了导航菜单的 <code>url</code> 属性值（<code>/</code> 和 <code>/en/</code>）在配置层面是正确的。</li></ol></li></ul><p>这些检查表明，问题出在 Hexo 的 <code>url_for</code> 辅助函数上。它在渲染链接时，会基于当前页面的 <code>root</code> 路径（如 <code>/en/</code>）对相对路径进行拼接，从而导致了 URL 路径的重复。</p><h3 id="阶段三：关键发现与终极解决方案"><a href="#阶段三：关键发现与终极解决方案" class="headerlink" title="阶段三：关键发现与终极解决方案"></a>阶段三：关键发现与终极解决方案</h3><p>在排查过程中，我偶然发现了一个来自 Butterfly 主题的 <code>switch-language.js</code> 脚本。这个脚本揭示了一个关键信息：<strong>在某些主题中，多语言切换并非简单地依赖 <code>url_for</code> 生成的静态链接，而是通过 JavaScript 动态处理的。</strong></p><p>该脚本中的 <code>initLanguageSwitchLinks</code> 函数会遍历所有带有特定类（<code>multiple-language-switch</code>）的链接，并为其添加点击事件监听器。当点击发生时，<code>handleLanguageSwitch</code> 函数会被调用，它会根据目标语言，<strong>手动构建正确的 URL</strong>（例如 <code>http://localhost:5000/</code> 或 <code>http://localhost:5000/en/</code>）并进行跳转。</p><p>这完美解释了为什么 <code>url_for</code> 生成的链接不正确，因为正确的跳转逻辑被设计为由前端 JavaScript 控制。</p><h4 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h4><p>基于以上发现，最终的解决方案是，结合 <code>switch-language.js</code> 的工作原理，对主题进行以下修改：</p><ol><li><p><strong>修改 EJS 模板</strong>: 在 <code>themes/volantis/layout/_partial/header.ejs</code> 中，为语言切换链接的 <code>&lt;li&gt;</code> 或 <code>&lt;a&gt;</code> 标签添加 <code>multiple-language-switch</code> 类。这使得 <code>switch-language.js</code> 能够识别并处理这些链接的点击事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例：找到生成语言切换链接的地方，添加 class --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu-item menu-item-type-post_type menu-item-object-page multiple-language-switch&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for(value.url) %&gt;&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>引入 JS 脚本</strong>: 将 <code>switch-language.js</code> 脚本引入到主题中。最稳妥的方法是在 Hexo 的主配置文件 <code>_config.yml</code> 中，通过 <code>inject</code> 选项将其注入到页面底部。</p><ul><li>首先，将 <code>switch-language.js</code> 文件放置在 <code>themes/volantis/source/js/</code> 目录下。</li><li>然后，在 <code>_config.yml</code> 中添加注入配置：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/switch-language.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>通过这些修改，语言切换功能将由 <code>switch-language.js</code> 脚本接管。它会忽略 <code>href</code> 属性中由 <code>url_for</code> 生成的错误链接，并在用户点击时，动态计算并跳转到正确的语言根路径。</p><p>虽然通过自己DIY可以实现，但是后续还有需要可以调整的地方，所以，如果想要真正好用，最好还是直接使用buffterfly这类直接支持国际化的主题。</p><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>本次排查和解决 Hexo 多语言导航链接问题的过程，使我深刻认识到：</p><ul><li><strong>理解主题和插件的内部工作机制至关重要。</strong> 表面上简单的链接问题，背后可能涉及到复杂的 JavaScript 逻辑和前端路由处理。不能只停留在模板和配置层面。</li><li><strong>调试是解决问题的关键。</strong> 通过分析浏览器开发者工具中的元素、网络请求和控制台日志，可以更准确地定位问题根源。</li><li><strong>跨主题借鉴解决方案。</strong> 当遇到棘手问题时，参考其他成熟主题（如 Butterfly）对相似功能的实现，可能会带来意想不到的启发。</li><li><strong>主题与插件的兼容性是重要考量。</strong> 在选择技术栈时，应优先考虑其对目标功能的官方支持和社区适配案例，以减少不必要的开发和调试工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文详细记录了在 Hexo 博客中使用 &lt;code&gt;hexo-multiple-language-generate&lt;/code&gt; 插件对 Volantis 主题进行多语言国际化时遇到的各种问题，包括目录结构调整、配置文件适配、导航链接错误、样式冲突</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="问题排查" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="多语言" scheme="https://ai.he0xwhale.xyz/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
    <category term="博客" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="前端" scheme="https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://ai.he0xwhale.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从 Hexo 国际化配置还原为默认状态（Volantis 主题完整修复指南）</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/02/hexo_i_18_n_revert_guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/02/hexo_i_18_n_revert_guide/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-07-08T03:19:31.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 在尝试为 Hexo 博客启用多语言功能，搭配 Volantis 主题与 <code>hexo-generator-index-i18n</code> 插件实现 <code>/</code> 显示 zh-CN，<code>/en/</code> 显示英文分页的过程中，出现了大量错误</p></blockquote><ul><li>首页 <code>Cannot GET /</code></li><li><code>/zh-CN/zh-CN/index.html</code> 等路径嵌套</li><li>所有文章混杂分页、不正确语言过滤</li><li>页码仍基于总文章数分页（比如 1&#x2F;4）</li></ul><p>  最终我决定<strong>完全撤销国际化支持，恢复 Hexo + Volantis 默认行为</strong>，并记录完整还原过程，方便自己或他人参考。</p><hr><h2 id="💡-尝试-Hexo-多语言支持过程（失败记录）"><a href="#💡-尝试-Hexo-多语言支持过程（失败记录）" class="headerlink" title="💡 尝试 Hexo 多语言支持过程（失败记录）"></a>💡 尝试 Hexo 多语言支持过程（失败记录）</h2><h3 id="1-使用-hexo-generator-index-i18n"><a href="#1-使用-hexo-generator-index-i18n" class="headerlink" title="1. 使用 hexo-generator-index-i18n"></a>1. 使用 <code>hexo-generator-index-i18n</code></h3><p>在根目录 <code>_config.yml</code> 添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator_i18n:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">languages:</span></span><br><span class="line">    <span class="attr">zh-CN:</span> <span class="string">index</span>    <span class="comment"># 期望生成 /index.html</span></span><br><span class="line">    <span class="attr">en:</span> <span class="string">en</span>          <span class="comment"># 生成 /en/index.html</span></span><br></pre></td></tr></table></figure><p>文章结构使用 <code>source/_posts/zh-CN/</code> 和 <code>source/_posts/en/</code>。 文章 front-matter 添加 <code>lang: zh-CN</code> 或 <code>lang: en</code>。</p><p><strong>结果：</strong></p><ul><li>多语言页面能访问 <code>/zh-CN/</code> 和 <code>/en/</code></li><li>但根目录 <code>/</code> 不会列出全部文章，且分页逻辑混乱</li><li><code>/public/zh-CN/zh-CN/index.html</code> 这种嵌套出现，路径异常</li></ul><h3 id="2-修改-archive-ejs-与-index-ejs-模板"><a href="#2-修改-archive-ejs-与-index-ejs-模板" class="headerlink" title="2. 修改 archive.ejs 与 index.ejs 模板"></a>2. 修改 <code>archive.ejs</code> 与 <code>index.ejs</code> 模板</h3><p>尝试用 <code>page.lang</code> 对文章进行语言过滤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const currentLang = page.lang || &#x27;zh-CN&#x27;;</span><br><span class="line">...</span><br><span class="line">site.posts.filter(post =&gt; post.lang === currentLang)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><ul><li>文章确实被筛选了，但分页总数仍为全局文章数</li><li>出现 <code>1/4</code> 页码，但其实该语言下只有 1 篇文章</li></ul><h3 id="3-使用-HTML-重定向方案"><a href="#3-使用-HTML-重定向方案" class="headerlink" title="3. 使用 HTML 重定向方案"></a>3. 使用 HTML 重定向方案</h3><p>尝试添加 <code>source/index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0; url=/zh-CN/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong> 无效，Hexo build 后根路径仍无首页，或被清空</p><h3 id="4-使用-hexo-generator-redirect-插件"><a href="#4-使用-hexo-generator-redirect-插件" class="headerlink" title="4. 使用 hexo-generator-redirect 插件"></a>4. 使用 <code>hexo-generator-redirect</code> 插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-redirect --save</span><br></pre></td></tr></table></figure><p>然后配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redirects:</span></span><br><span class="line">  <span class="string">&quot;/&quot;</span><span class="string">:</span> <span class="string">&quot;/zh-CN/&quot;</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong> 安装失败（依赖 Hexo 5，当前为 Hexo 6.3），或 <code>/</code> 页面失效（Cannot GET &#x2F;）</p><p>最终，在对 Hexo、Volantis、分页插件等源码调试后，判断国际化插件目前与 Volantis 的首页分页机制冲突过多，决定<strong>彻底撤回</strong>。</p><hr><h2 id="✅-恢复操作步骤"><a href="#✅-恢复操作步骤" class="headerlink" title="✅ 恢复操作步骤"></a>✅ 恢复操作步骤</h2><h3 id="1-还原根目录-config-yml-配置"><a href="#1-还原根目录-config-yml-配置" class="headerlink" title="1. 还原根目录 _config.yml 配置"></a>1. 还原根目录 <code>_config.yml</code> 配置</h3><p>删除国际化相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator_i18n:</span> <span class="string">...</span>    <span class="comment"># ❌ 删除</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>              <span class="comment"># ✅ 设置默认语言</span></span><br><span class="line"><span class="attr">index_generator:</span>             <span class="comment"># ✅ 使用默认分页生成器</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure><h3 id="2-卸载国际化插件"><a href="#2-卸载国际化插件" class="headerlink" title="2. 卸载国际化插件"></a>2. 卸载国际化插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index-i18n</span><br><span class="line">npm uninstall hexo-generator-redirect</span><br><span class="line">npm install hexo-generator-index</span><br></pre></td></tr></table></figure><h3 id="3-合并文章结构"><a href="#3-合并文章结构" class="headerlink" title="3. 合并文章结构"></a>3. 合并文章结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> <span class="built_in">source</span>/_posts/zh-CN/* <span class="built_in">source</span>/_posts/</span><br><span class="line"><span class="built_in">mv</span> <span class="built_in">source</span>/_posts/en/* <span class="built_in">source</span>/_posts/</span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">source</span>/_posts/zh-CN/</span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">source</span>/_posts/en/</span><br></pre></td></tr></table></figure><p>删除每篇文章的 <code>lang:</code> 字段（可选）</p><h3 id="4-删除语言静态页面及-index-html"><a href="#4-删除语言静态页面及-index-html" class="headerlink" title="4. 删除语言静态页面及 index.html"></a>4. 删除语言静态页面及 index.html</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">source</span>/en/ <span class="built_in">source</span>/zh-CN/</span><br><span class="line"><span class="built_in">rm</span> -f <span class="built_in">source</span>/index.html <span class="built_in">source</span>/index.md</span><br></pre></td></tr></table></figure><h3 id="5-恢复-Volantis-模板"><a href="#5-恢复-Volantis-模板" class="headerlink" title="5. 恢复 Volantis 模板"></a>5. 恢复 Volantis 模板</h3><p>将 <code>themes/volantis/layout/_partial/archive.ejs</code> 文件内容还原为原始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (site.posts &amp;&amp; site.posts.length &gt; 0) &#123; %&gt;</span><br><span class="line">&lt;section class=&quot;post-list&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (page.current === 1) &#123; %&gt;</span><br><span class="line">    &lt;% site.posts.filter(post =&gt; post.pin).sort(&#x27;date&#x27;, -1).each(function(post)&#123; %&gt;</span><br><span class="line">      &lt;div class=&#x27;post-wrapper&#x27;&gt;</span><br><span class="line">        &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;% site.pages.filter(post =&gt; post.pin).sort(&#x27;date&#x27;, -1).each(function(post)&#123; %&gt;</span><br><span class="line">      &lt;div class=&#x27;post-wrapper&#x27;&gt;</span><br><span class="line">        &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% page.posts.filter(post =&gt; !post.pin).each(function(post)&#123; %&gt;</span><br><span class="line">    &lt;div class=&#x27;post-wrapper&#x27;&gt;</span><br><span class="line">      &lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;% &#125;) %&gt;</span><br><span class="line"></span><br><span class="line">&lt;/section&gt;</span><br><span class="line">  &lt;% if (page.total &gt; 1) &#123; %&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;div class=&quot;prev-next&quot;&gt;</span><br><span class="line">      &lt;% if (page.prev != 0) &#123; %&gt;</span><br><span class="line">        &lt;a class=&quot;prev&quot; rel=&quot;prev&quot; href=&quot;&lt;%= url_for(page.prev_link) %&gt;&quot;&gt;</span><br><span class="line">          &lt;section class=&quot;post prev white-box &lt;%- theme.custom_css.body.effect.join(&#x27; &#x27;) %&gt;&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;fa-solid fa-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&lt;%- __(&#x27;post.prev_page&#x27;) %&gt;&amp;nbsp;</span><br><span class="line">          &lt;/section&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;p class=&quot;current&quot;&gt;</span><br><span class="line">        &lt;%= page.current %&gt; / &lt;%= page.total %&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &lt;% if (page.next != 0) &#123; %&gt;</span><br><span class="line">        &lt;a class=&quot;next&quot; rel=&quot;next&quot; href=&quot;&lt;%= url_for(page.next_link) %&gt;&quot;&gt;</span><br><span class="line">          &lt;section class=&quot;post next white-box &lt;%- theme.custom_css.body.effect.join(&#x27; &#x27;) %&gt;&quot;&gt;</span><br><span class="line">            &amp;nbsp;&lt;%- __(&#x27;post.next_page&#x27;) %&gt;&amp;nbsp;&lt;i class=&quot;fa-solid fa-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">          &lt;/section&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="6-重新构建"><a href="#6-重新构建" class="headerlink" title="6. 重新构建"></a>6. 重新构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><hr><h2 id="✅-最终恢复效果"><a href="#✅-最终恢复效果" class="headerlink" title="✅ 最终恢复效果"></a>✅ 最终恢复效果</h2><table><thead><tr><th>功能</th><th>状态</th></tr></thead><tbody><tr><td>首页 &#x2F;</td><td>✅ 显示所有文章，不再跳转</td></tr><tr><td><code>/zh-CN/</code>、<code>/en/</code></td><td>❌ 不再存在</td></tr><tr><td>分页</td><td>✅ 按总文章数分页</td></tr><tr><td>模板</td><td>✅ 使用 Volantis 默认逻辑</td></tr></tbody></table><hr><h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a>📌 总结</h2><p>Hexo 当前的分页逻辑与 Volantis 的模板结构，在使用 <code>hexo-generator-index-i18n</code> 时存在以下问题：</p><ol><li><code>page.posts</code> 提供的是全局文章数组，分页数量基于所有文章</li><li>即便筛选文章显示了部分，分页导航仍照旧分页（出现 1&#x2F;4，2&#x2F;4）</li><li>Volantis 模板未内建对多语言分页路径的完整支持</li><li>插件本身未适配 Hexo 6.x + Volantis 最新模板结构</li></ol><p>⚠️ 建议未来如需中英文独立首页分页，可以考虑：</p><ul><li>使用多 Hexo 子站部署</li><li>使用标签（如 <code>tag: en</code>）做筛选页</li><li>自定义 index 页 + layout</li></ul><hr><p>希望本文对未来再次尝试 Hexo 多语言配置有所帮助，也欢迎基于此模板进一步扩展语言支持方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 在尝试为 Hexo 博客启用多语言功能，搭配 Volantis 主题与 &lt;code&gt;hexo-generator-index-i18n&lt;/code&gt; 插件实现 &lt;code&gt;/&lt;/code&gt; 显示 zh-CN，&lt;code&gt;/en/&lt;/code&gt; 显</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="问题排查" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="博客搭建" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="多语言" scheme="https://ai.he0xwhale.xyz/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
    <category term="排障记录" scheme="https://ai.he0xwhale.xyz/tags/%E6%8E%92%E9%9A%9C%E8%AE%B0%E5%BD%95/"/>
    
    <category term="i18n" scheme="https://ai.he0xwhale.xyz/tags/i18n/"/>
    
    <category term="国际化" scheme="https://ai.he0xwhale.xyz/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
    <category term="博客恢复" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>一次离奇的VS Code调试经历：当眼见不再为实</title>
    <link href="https://ai.he0xwhale.xyz/2025/07/01/strange-debug-story/"/>
    <id>https://ai.he0xwhale.xyz/2025/07/01/strange-debug-story/</id>
    <published>2025-07-01T03:11:00.000Z</published>
    <updated>2025-07-08T03:17:43.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我在开发一个 VS Code 插件时，遇到了一个堪称我职业生涯中最离奇的调试问题。它耗费了我数小时的时间，并最终让我深刻理解了“眼见不一定为实”。</p></blockquote><h3 id="问题的开端"><a href="#问题的开端" class="headerlink" title="问题的开端"></a>问题的开端</h3><p>一切都始于一个简单的函数。在我的 TypeScript 代码中，有这样一段逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/commands/removeTargetCommand.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title function_">execute</span>(<span class="attr">targetPath</span>?: <span class="built_in">string</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="title class_">Logger</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`RemoveTargetCommand: execute started with targetPath: <span class="subst">$&#123;targetPath&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果未提供目标路径，则退出</span></span><br><span class="line">  <span class="keyword">if</span> (!targetPath) &#123;</span><br><span class="line">    <span class="title class_">Logger</span>.<span class="title function_">error</span>(<span class="string">&quot;RemoveTargetCommand: No target path provided&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我在这段代码中进行单步调试时，诡异的事情发生了：调试器的高亮显示，程序<strong>首先</strong>跳到了 <code>if (!targetPath)</code> 这一行，<strong>然后</strong>才跳回到 <code>Logger.log(...)</code>。执行顺序看起来完全是颠倒的！</p><p><img src="/../../../../images/screenshot/2025-07-01%2015-25_strange-debug-story.gif" alt="alt text"></p><h3 id="第一轮排查：Source-Map"><a href="#第一轮排查：Source-Map" class="headerlink" title="第一轮排查：Source Map"></a>第一轮排查：Source Map</h3><p>作为一名开发者，我的第一反应是：<strong>Source Map 出错了</strong>。</p><p>Source Map 是连接编译后 JavaScript 和原始 TypeScript 代码的桥梁。如果它出了问题，调试器显示错乱的行号是常有的事。于是，我开始了一系列教科书式的排查：</p><ol><li><strong>检查 <code>tsconfig.json</code></strong>：确认 <code>&quot;sourceMap&quot;: true</code> 已开启。</li><li><strong>检查 <code>webpack.config.js</code></strong>：确认 <code>devtool: &quot;source-map&quot;</code> 配置正确。</li><li><strong>清理并重建</strong>：删除了所有编译产物（<code>dist</code> 和 <code>out</code> 目录），并重新运行 <code>npm run compile</code>。</li></ol><p>然而，在完成了所有这些操作后，问题依旧。</p><h3 id="第二轮排查：日志系统和-JIT-优化"><a href="#第二轮排查：日志系统和-JIT-优化" class="headerlink" title="第二轮排查：日志系统和 JIT 优化"></a>第二轮排查：日志系统和 JIT 优化</h3><p>既然不是简单的 Source Map 配置问题，我开始怀疑更深层次的原因。</p><ol><li><strong>日志系统是异步的吗？</strong> 我检查了 <code>Logger</code> 类的实现。它是完全同步的，不存在任何缓冲或异步操作。排除。</li><li><strong>是 JIT 优化导致的吗？</strong> 我怀疑是 V8 引擎的即时编译（JIT）优化（如函数内联）导致了代码重排，从而迷惑了调试器。我甚至写了一个“反优化”的包装函数来包裹日志调用，试图阻止 JIT 的优化。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试阻止 JIT 优化的临时代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">logWithNoInline</span> = (<span class="params"><span class="attr">msg</span>: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123; count++; &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="title class_">Logger</span>.<span class="title function_">log</span>(msg); &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">logWithNoInline</span>(<span class="string">`...`</span>);</span><br></pre></td></tr></table></figure><p>结果，问题还是没有解决。这让我陷入了沉思。</p><h3 id="第三轮排查：未绑定的断点"><a href="#第三轮排查：未绑定的断点" class="headerlink" title="第三轮排查：未绑定的断点"></a>第三轮排查：未绑定的断点</h3><p>就在我几乎要放弃的时候，我注意到了一个关键细节：当我想在 <code>Logger.log(...)</code> 这一行设置断点时，VS Code 显示这是一个 <strong>“未绑定断点” (Unbound breakpoint)</strong>。</p><p>这是一个决定性的线索！</p><p>“未绑定断点”意味着调试器在编译后的 JavaScript 文件中，找不到任何可以与这一行 TypeScript 代码对应的、可执行的代码。这强烈暗示，<strong><code>Logger.log(...)</code> 这一行在编译打包后，被优化掉了！</strong></p><p>我立刻检查了 <code>package.json</code> 中的 <code>package</code> 脚本，它使用了 <code>webpack --mode production</code>。在生产模式下，Webpack 会启用 <code>terser</code> 进行代码压缩，而 <code>terser</code> 的默认行为之一就是移除 <code>console.log</code> 这样的“无副作用”代码。</p><p>我通过修改 <code>webpack.config.js</code> 来禁用这个优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="function">(<span class="params">compiler</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">          <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">            <span class="attr">compress</span>: &#123;</span><br><span class="line">              <span class="attr">drop_console</span>: <span class="literal">false</span>, <span class="comment">// 保留console.*</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;).<span class="title function_">apply</span>(compiler);</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并安装了 <code>terser-webpack-plugin</code>。我满怀信心地认为，问题已经解决了。</p><p>然而，现实再次给了我沉重一击：<strong>问题依然存在。</strong></p><h3 id="最终的测试：回归本源"><a href="#最终的测试：回归本源" class="headerlink" title="最终的测试：回归本源"></a>最终的测试：回归本源</h3><p>在排除了所有软件配置层面的可能性后，我不得不面对最后一个，也是最不愿意承认的猜测：这是一个更底层的，与我的开发环境本身有关的 Bug。</p><p>为了验证这一点，我进行了终极测试：</p><ol><li>创建了一个纯粹的 <code>test-debug.js</code> 文件，模拟核心逻辑，不依赖任何项目配置。</li><li>使用 <code>node --inspect-brk test-debug.js</code> 命令，直接用 Node.js 的调试模式运行它。</li><li>在 VS Code 中附加到这个 Node.js 进程进行调试。</li></ol><p>在这个最纯净的环境中，我得到了程序的最终输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute started with targetPath: undefined</span><br><span class="line">No target path provided</span><br></pre></td></tr></table></figure><p>这个输出顺序无可辩驳地证明了：<strong>代码的实际执行顺序，自始至终都是正确的！</strong></p><h3 id="结论：当调试器“说谎”时"><a href="#结论：当调试器“说谎”时" class="headerlink" title="结论：当调试器“说谎”时"></a>结论：当调试器“说谎”时</h3><p>我们所有的努力，都是在试图修复一个实际上并不存在的“代码执行顺序”问题。真正的问题在于，<strong>VS Code 调试器在可视化渲染当前执行行时出错了</strong>。</p><p>它让我们“看到”了一个颠倒的执行顺序，但底层的 V8 引擎和 Node.js 依然在忠实地、正确地执行我们的代码。</p><p><strong>经验教训</strong></p><ol><li><strong>眼见不为实</strong>：不要 100% 相信调试器 UI 的高亮显示，尤其是在复杂的项目中（TypeScript + Webpack + Source Map）。</li><li><strong>日志是你的终极真相</strong>：在怀疑执行顺序时，<code>console.log</code> 和日志点 (Logpoints) 是比单步调试更可靠的真相来源。查看“调试控制台”的输出，而不是代码编辑器的跳动。</li><li><strong>隔离问题</strong>：当遇到无法解释的问题时，创建一个最小化的、纯净的复现环境，是剥离复杂配置、直达问题核心的有效手段。</li><li><strong>关注最终结果</strong>：如果程序的最终行为是正确的，那么有时候我们可以接受调试器在可视化上的一些小瑕疵，继续前进。</li></ol><p>这次离奇的经历提醒我，即使在今天高度发达的工具链中，我们依然需要保持批判性的思维，并通过多种方式交叉验证，才能找到问题的真正根源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我在开发一个 VS Code 插件时，遇到了一个堪称我职业生涯中最离奇的调试问题。它耗费了我数小时的时间，并最终让我深刻理解了“眼见不一定为实”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题的开端&quot;&gt;&lt;a href=&quot;#问题的开端&quot; </summary>
      
    
    
    
    <category term="技术分享" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="问题排查" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="VS Code" scheme="https://ai.he0xwhale.xyz/tags/VS-Code/"/>
    
    <category term="Debugging" scheme="https://ai.he0xwhale.xyz/tags/Debugging/"/>
    
    <category term="TypeScript" scheme="https://ai.he0xwhale.xyz/tags/TypeScript/"/>
    
    <category term="Webpack" scheme="https://ai.he0xwhale.xyz/tags/Webpack/"/>
    
    <category term="Node.js" scheme="https://ai.he0xwhale.xyz/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>解决 Gemini CLI 认证超时及日常使用问题</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/27/gemini_cli_auth_fix/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/27/gemini_cli_auth_fix/</id>
    <published>2025-06-27T02:55:16.000Z</published>
    <updated>2025-07-08T03:20:33.405Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你是否曾被命令行工具的认证超时问题困扰？当 Google Gemini CLI 尝试通过浏览器进行身份验证时，一个看似简单的步骤却可能隐藏着复杂的网络和配置挑战。本文将深入剖析我如何从一个棘手的认证超时问题入手，通过系统化的排查与调试，最终实现 Gemini CLI 的顺畅使用。这个过程不仅恢复了我的正常工作流程，更让我对现代命令行工具的认证机制、网络代理原理及问题诊断方法有了前所未有的深入理解。</p></blockquote><h3 id="问题初现-浏览器回调请求挂起"><a href="#问题初现-浏览器回调请求挂起" class="headerlink" title="问题初现: 浏览器回调请求挂起"></a>问题初现: 浏览器回调请求挂起</h3><p>最初，当我依照 Gemini CLI 提供的指示，点击浏览器中的 “Sign in” 按钮后，浏览器会尝试重定向到一个本地的回调 URL，通常是 <code>http://localhost:&lt;某个端口&gt;/oauth2callback?...</code>。在我遇到的具体情况中，端口号最初显示为 <code>33805</code>，后来在 Wireshark 中捕获到的是 <code>39065</code>。然而，无论端口如何，这个关键的重定向请求在 Chrome 浏览器的 <code>Network</code> 标签页中一直显示为 <code>pending</code> 状态，而在 Firefox 中甚至没有任何网络活动记录（显示为空），这无疑是一个不祥之兆。最终，这种无响应导致了 Gemini CLI 在终端显示令人沮丧的错误信息：“Authentication timed out. Please try again.”（认证超时。请重试）。</p><p>为了初步诊断这一问题，我采取了一些基本的排查步骤:</p><ul><li><p><strong>浏览器无痕模式和不同浏览器测试:</strong> 考虑到浏览器缓存、扩展或插件可能引起的干扰，我特意在 Chrome 的无痕模式下以及使用 Firefox 浏览器进行了测试。这旨在排除因浏览器环境个性化设置或第三方插件导致的请求阻塞，然而不幸的是，问题依然顽固存在，没有得到缓解。</p></li><li><p><strong>本地端口可达性检查:</strong> 我使用 <code>telnet localhost &lt;端口号&gt;</code> 命令来确认 Gemini CLI 预期监听的本地端口是否确实处于开放状态并可被访问。例如，我测试了 <code>telnet localhost 34253</code> 和 <code>telnet localhost 33805</code>。<code>telnet</code> 命令的成功连接表明，从操作系统层面看，该端口是开放的，并没有被其他应用程序明确占用或被防火墙完全阻止入站连接。</p></li></ul><p>然而，尽管这些初步检查都显示正常，但仍未能直接揭示浏览器请求为何无法成功抵达本地服务器的深层原因。请求的 <code>pending</code> 状态暗示着它可能在网络栈的更早阶段就被卡住或放弃了，甚至没有真正发送出去。</p><h3 id="Wireshark-诊断-发现-HTTP-408-错误"><a href="#Wireshark-诊断-发现-HTTP-408-错误" class="headerlink" title="Wireshark 诊断: 发现 HTTP 408 错误"></a>Wireshark 诊断: 发现 HTTP 408 错误</h3><p>为了更深入地了解网络通信的底层细节，我决定启用专业的网络协议分析工具 Wireshark 进行抓包。我的目标是捕获 Loopback 接口上的所有相关流量，特别是目标端口为 <code>33805</code>（或后来观测到的 <code>39065</code>）的 TCP 数据包。</p><p>最初的抓包尝试，当我在 Loopback 接口上应用 <code>tcp.port == 33805</code> 的过滤条件时，出乎意料地没有发现任何数据包。这个结果让我一度重新怀疑，是否我的浏览器请求根本就没有从应用层成功发送到网络层，或者它在发送之前就被某些机制（例如浏览器内部的安全策略）给悄无声息地阻止了。</p><p>为了进一步排除这种可能性，并针对潜在的 HTTPS 到 HTTP 重定向阻止（即“混合内容”问题），我尝试了一个临时的、仅用于调试的措施: 在 Chrome 浏览器的 <code>chrome://\flags/#allow-insecure-downloads</code> 选项中进行调整，尽管它主要与下载相关，但有时也可能影响其他类型的混合内容处理。</p><p>重新启动 Wireshark 抓包，并再次触发 Gemini CLI 的登录流程后，这次我终于捕获到了关键且决定性的网络通信信息:</p><ul><li><p><strong>成功发出的 HTTP GET 请求:</strong> Wireshark 记录到浏览器确实向 <code>http://localhost:&lt;动态分配的端口，如39065&gt;/oauth2callback?...</code> 发送了一个完整的 HTTP GET 请求，其中包含了 OAuth 认证所需的 <code>state</code> 和 <code>code</code> 参数。这里需要注意的是，由于本地回调服务器的端口通常是动态分配的，每次尝试都可能略有不同。Wireshark 的捕获证实了浏览器确实发出了请求，这彻底排除了浏览器未能发出请求的可能性，也澄清了之前关于混合内容阻止的疑虑—浏览器确实尝试了重定向。</p></li><li><p><strong>服务器返回 <code>HTTP/1.1 408 Request Timeout</code>:</strong> 紧随浏览器请求之后，Wireshark 捕获到来自本地服务器的一个 HTTP 响应，其状态码是 <code>408 Request Timeout</code>。这是一个至关重要的信号！<code>408 Request Timeout</code> 意味着服务器端（在本例中，是 Gemini CLI 内部启动的用于接收 OAuth 回调的 Web 服务器）在等待客户端（浏览器）完成请求时发生了超时。然而，结合此情此景，它更常指示服务器在收到请求后，其<strong>内部处理流程</strong>未能按时完成。服务器在收到回调请求后，通常会立即向 Google 的 OAuth 2.0 令牌端点发起第二个服务器到服务器的请求，用从浏览器获取的 <code>code</code> 去交换实际的 <code>access_token</code> 和 <code>refresh_token</code>。如果这个内部的令牌交换过程因为某种原因耗时过长或失败，本地服务器就会因等待超时而向浏览器返回 <code>408</code> 错误。</p></li><li><p><strong>随后的 TCP <code>RST, ACK</code> 包:</strong> 在 <code>408</code> 响应之后，还伴随着一个 TCP <code>RST, ACK</code> 包。<code>RST</code>（Reset）标志表示连接被突然终止。这通常发生在连接状态不匹配、协议错误，或者在收到 <code>408</code> 响应后，服务器决定立即关闭该连接，而不是等待正常的 TCP 关闭握手。这进一步印证了本地服务器在处理请求后遇到了某种无法继续的状况，并主动或被动地断开了与浏览器的连接。</p></li></ul><p>这些抓包结果清晰地表明，问题不再是浏览器无法发送请求，而是 <strong>Gemini CLI 应用程序在接收到 OAuth 回调后，其内部处理逻辑未能成功完成，导致了超时</strong>。焦点现在完全转移到了 Gemini CLI 内部的网络通信和业务逻辑上。</p><h3 id="定位根源-CLI-未走代理访问-Google-API"><a href="#定位根源-CLI-未走代理访问-Google-API" class="headerlink" title="定位根源: CLI 未走代理访问 Google API"></a>定位根源: CLI 未走代理访问 Google API</h3><p>既然 Wireshark 已经确认本地服务器接收到了浏览器发来的 OAuth 回调请求，并且返回了 <code>408 Request Timeout</code>，那么最合理的推断是 Gemini CLI 在接收到 <code>code</code> 后，尝试向 <strong>Google OAuth 2.0 令牌端点</strong>（例如 <code>oauth2.googleapis.com</code> 或 <code>www.googleapis.com</code>）发送一个 <strong>服务器到服务器</strong> 的请求，用这个 <code>code</code> 去交换实际的 <code>access_token</code> 和 <code>refresh_token</code>。然而，由于我的网络环境访问 Google 相关服务必须通过代理，而 <code>npx</code> 运行的 Node.js 应用程序默认可能没有自动识别或使用我的系统代理设置，导致这个关键的<strong>出站请求</strong>未能成功抵达 Google 的服务器，从而在 CLI 内部引发了超时。</p><p><code>npx</code> 是一个强大的工具，允许我们执行远程或本地的 Node.js 包可执行文件，而无需全局安装它们。当 <code>npx</code> 启动 <code>gemini-cli</code> 时，它实际上是下载了 Git 仓库，并在一个临时环境中运行其中的 Node.js 脚本。Node.js 应用程序通常会尝试读取标准的环境变量来配置其代理行为。如果这些环境变量没有被正确设置或应用程序没有被显式告知使用代理，它将尝试直接连接外部网络，这在需要代理的环境下必然会失败。</p><p><strong>最终解决方案:</strong></p><p>为了强制 Node.js 应用程序（即 Gemini CLI）在进行出站网络请求时使用代理，我在启动 Gemini CLI 之前，通过设置系统环境变量来配置代理信息。这些环境变量是 Node.js 及其许多 HTTP 客户端库默认会查找的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS 用户在终端中执行</span></span><br><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;http://127.0.0.1:7890&quot;</span> <span class="comment"># 替换为你的 HTTP 代理地址和端口，例如：http://your.proxy.server:port</span></span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;http://127.0.0.1:7890&quot;</span> <span class="comment"># 替换为你的 HTTPS 代理地址和端口，通常与 HTTP 代理相同</span></span><br><span class="line"><span class="built_in">export</span> NO_PROXY=<span class="string">&quot;localhost,127.0.0.1&quot;</span>    <span class="comment"># 关键：确保 localhost 请求不通过代理，避免内部回调也走代理导致问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows 用户在命令提示符或 PowerShell 中执行</span></span><br><span class="line"><span class="built_in">set</span> HTTP_PROXY=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">set</span> HTTPS_PROXY=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">set</span> NO_PROXY=localhost,127.0.0.1</span><br></pre></td></tr></table></figure><p><strong>深入理解 <code>NO_PROXY</code> 的双重重要性:</strong> <code>NO_PROXY</code> 环境变量在代理配置中扮演着关键角色，它明确指定了哪些目标地址的流量不应通过代理服务器转发。在此场景下，将其设置为 <code>localhost,127.0.0.1</code> 具有双重意义:首先，它确保了浏览器向本地 Gemini CLI 发送的 OAuth 回调请求能够直接抵达，而不会被错误地路由到外部代理，从而避免了“内卷”式的代理循环或不必要的网络延迟。其次，如果本地回调请求被强制通过代理，不仅效率低下，还可能因代理服务器不支持本地地址解析或安全策略限制而导致连接失败。因此，正确配置 <code>NO_PROXY</code> 是确保本地回调路径畅通无阻，并让 CLI 的出站请求能通过代理访问外部 Google API 的关键平衡点。确保 <code>NO_PROXY</code> 的值是逗号分隔的列表，且不包含空格，以保证其正确解析。</p><p>设置这些环境变量后，再次运行 <code>npx https://github.com/google-gemini/gemini-cli</code>，认证过程得以顺利完成！CLI 内部的 Node.js 进程现在能够通过指定的代理成功连接到 Google 的 OAuth 令牌端点，完成了令牌交换，从而解决了认证超时的问题。</p><h3 id="日常使用优化-全局安装-gemini-命令"><a href="#日常使用优化-全局安装-gemini-命令" class="headerlink" title="日常使用优化: 全局安装 gemini 命令"></a>日常使用优化: 全局安装 <code>gemini</code> 命令</h3><p>尽管 <code>npx</code> 提供了一种便捷的方式来运行远程的 Node.js 可执行文件，但其本质是为<strong>临时执行</strong>而设计的。每次使用 <code>npx https://github.com/google-gemini/gemini-cli</code> 时，它都会在你的系统临时目录中（例如 <code>~/.npm/_npx</code>）下载或克隆 Git 仓库、安装依赖，并执行相应的命令。这意味着每次使用都需要一定的准备时间，而且最重要的是，当你关闭终端会话或 <code>npx</code> 进程完成后，它下载和安装的文件通常会被自动清理掉。因此，当你下一次尝试直接在终端中输入 <code>gemini</code> 命令时，系统会提示“没有该命令”，因为它已经不在你的系统 PATH 环境变量指向的任何目录中了。这对于需要频繁使用的 CLI 工具来说，显然不够方便。</p><p>为了实现 <code>gemini</code> 命令的便捷和持久化使用，使其能够像其他常规命令行工具一样，在任何时候、任何地方都能直接运行，我们需要将其进行<strong>全局安装</strong>。</p><p>我最初尝试通过 Git URL (<code>npm install -g https://github.com/google-gemini/gemini-cli</code>) 进行全局安装，但这遇到了几个错误: Git 仓库相关错误（<code>fatal: 不是 git 仓库</code>）和 Node.js 模块未找到错误（<code>Cannot find package &#39;esbuild&#39;</code>）。这些错误表明，<code>npm</code> 在从 Git URL 安装时，实际上会尝试在本地克隆的临时仓库中执行项目的构建脚本（例如 <code>npm run bundle</code>），而这些脚本可能依赖于完整的 Git 环境或特定的模块路径设置，这在 <code>npm</code> 的临时构建环境中可能无法满足，从而导致构建失败。</p><p><strong>最终解决方案:</strong></p><p>最可靠和推荐的方法是直接从 <strong>npm registry</strong> 全局安装预编译好的包。npm registry 存储的是已经打包和编译好的分发版本，这意味着 <code>npm</code> 不需要再在本地执行复杂的构建脚本，只需要下载并解压即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @google/gemini-cli</span><br></pre></td></tr></table></figure><ul><li><p><code>npm install -g</code>: 这是 Node.js 包管理器 <code>npm</code> 的命令，<code>-g</code> 标志表示进行全局安装，会将包的可执行文件放置到系统 PATH 环境变量所包含的目录中，使得 <code>gemini</code> 命令在任何位置都可直接调用。</p></li><li><p><code>@google/gemini-cli</code>: 这是发布到 npm registry 的官方包名称，确保了下载的是稳定且经过测试的版本。</p></li></ul><p><strong>如果 <code>npm</code> 在下载包时也需要代理</strong>（因为 <code>npm</code> 自身的网络请求也可能受网络环境限制），你需要额外配置 <code>npm</code> 的代理设置，这会告知 <code>npm</code> 在其所有的网络请求中都使用指定的代理服务器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy http://127.0.0.1:7890</span><br><span class="line">npm config <span class="built_in">set</span> https-proxy http://127.0.0.1:7890</span><br><span class="line">npm config <span class="built_in">set</span> no-proxy localhost,127.0.0.1</span><br></pre></td></tr></table></figure><p><code>npm config set</code> 命令会将代理设置写入你的 npm 配置文件（通常是 <code>~/.npmrc</code>），使其永久生效。</p><p>成功全局安装并配置好代理后，我就可以直接在任何终端会话中输入 <code>gemini</code> 命令来启动 Gemini CLI 了，并且它能够在我需要代理的网络环境下，顺畅地进行认证和后续操作。</p><hr><p>通过这次全面的排查和学习，我不仅成功解决了 Gemini CLI 的认证超时顽疾，使其在我需要代理的网络环境下能够正常工作，还优化了 <code>gemini</code> 命令的日常使用体验。更重要的是，这个过程让我对复杂的网络通信（尤其是内外部代理）、CLI 工具的认证机制、Node.js 包管理的不同安装方式有了更深入、更实际的理解。这再次印证了在故障诊断中，逐步缩小范围、利用专业工具（如 Wireshark）并理解底层原理的重要性。现在，我可以顺畅且高效地进行云操作，也为未来遇到类似问题积累了宝贵的经验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你是否曾被命令行工具的认证超时问题困扰？当 Google Gemini CLI 尝试通过浏览器进行身份验证时，一个看似简单的步骤却可能隐藏着复杂的网络和配置挑战。本文将深入剖析我如何从一个棘手的认证超时问题入手，通过系统化的排查与调试，最终实现 G</summary>
      
    
    
    
    <category term="技术分享" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="Gemini" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Gemini/"/>
    
    
    <category term="Gemini" scheme="https://ai.he0xwhale.xyz/tags/Gemini/"/>
    
    <category term="CLI" scheme="https://ai.he0xwhale.xyz/tags/CLI/"/>
    
    <category term="认证" scheme="https://ai.he0xwhale.xyz/tags/%E8%AE%A4%E8%AF%81/"/>
    
    <category term="代理" scheme="https://ai.he0xwhale.xyz/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="网络" scheme="https://ai.he0xwhale.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Troubleshooting" scheme="https://ai.he0xwhale.xyz/tags/Troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中 URL 路径出现重复日期的解决方案</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/24/hexo_permalink_fix/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/24/hexo_permalink_fix/</id>
    <published>2025-06-24T03:00:00.000Z</published>
    <updated>2025-07-08T03:16:04.535Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Hexo 搭建博客时，你可能会遇到如下问题：</p><blockquote><p>文章的 URL 路径中出现了重复的日期字段，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/2025/06/24/2025/06/24/volantis_cyberpunk_style_avatar_bug/</span><br></pre></td></tr></table></figure></blockquote><p>这通常是由于文章的物理路径与 Hexo 的默认 <code>permalink</code> 规则叠加造成的，本文将介绍如何避免 URL 中重复的日期路径。</p><h2 id="🚩-问题复现示例"><a href="#🚩-问题复现示例" class="headerlink" title="🚩 问题复现示例"></a>🚩 问题复现示例</h2><p>假设文章的物理路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source/_posts/2025/06/24/volantis_cyberpunk_style_avatar_bug.md</span><br></pre></td></tr></table></figure><p>同时 Front Matter 中包含：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">2025-06-24 10:00:00</span></span><br></pre></td></tr></table></figure><p>而 Hexo 默认的 <code>permalink</code> 配置是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><p>此时构建出来的 URL 就会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2025/06/24/2025/06/24/volantis_cyberpunk_style_avatar_bug/</span><br></pre></td></tr></table></figure><h2 id="✅-解决方案一：修改全局-permalink-配置-简化目录结构"><a href="#✅-解决方案一：修改全局-permalink-配置-简化目录结构" class="headerlink" title="✅ 解决方案一：修改全局 permalink 配置 + 简化目录结构"></a>✅ 解决方案一：修改全局 permalink 配置 + 简化目录结构</h2><ol><li><p>打开 Hexo 根目录下的 <code>_config.yml</code>；</p></li><li><p>修改 <code>permalink</code> 设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure></li><li><p>移动你的文章 <code>.md</code> 文件至 <code>_posts/</code> 根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> <span class="built_in">source</span>/_posts/2025/06/24/volantis_cyberpunk_style_avatar_bug.md <span class="built_in">source</span>/_posts/</span><br></pre></td></tr></table></figure></li></ol><p>最终构建出来的 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2025/06/24/volantis_cyberpunk_style_avatar_bug/</span><br></pre></td></tr></table></figure><h3 id="如果你不想保留日期路径："><a href="#如果你不想保留日期路径：" class="headerlink" title="如果你不想保留日期路径："></a>如果你不想保留日期路径：</h3><p>将 <code>_config.yml</code> 中的 permalink 改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure><p>则构建 URL 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/volantis_cyberpunk_style_avatar_bug/</span><br></pre></td></tr></table></figure><h2 id="✅-解决方案二：为单篇文章自定义-permalink"><a href="#✅-解决方案二：为单篇文章自定义-permalink" class="headerlink" title="✅ 解决方案二：为单篇文章自定义 permalink"></a>✅ 解决方案二：为单篇文章自定义 permalink</h2><p>如果你只想修改某篇文章的访问路径，可以在其 Front Matter 中手动设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">/2025/06/24/volantis_cyberpunk_style_avatar_bug/</span></span><br></pre></td></tr></table></figure><p>这样就不会受物理路径和全局 permalink 设置的影响，Hexo 将使用你指定的 URL。</p><h2 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h2><table><thead><tr><th>方法</th><th>操作</th><th>适用范围</th><th>效果</th></tr></thead><tbody><tr><td>修改 <code>_config.yml</code> 配置 + 整理 <code>_posts</code> 结构</td><td>修改 <code>permalink</code> 并搬移文章</td><td>全局生效</td><td>清晰、统一的 URL 路径</td></tr><tr><td>为单篇文章设置 <code>permalink</code></td><td>修改文章 Front Matter</td><td>局部定制</td><td>灵活配置路径</td></tr></tbody></table><hr><p>希望本文能帮你清理掉 URL 中冗余的日期路径，保持博客结构清晰简洁。<br>如果你想要我自动批量调整历史文章结构或生成脚本，请留言交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用 Hexo 搭建博客时，你可能会遇到如下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章的 URL 路径中出现了重复的日期字段，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="博客优化" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Volantis 主题下自定义吉卜力风格与柔和配色的实践</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/20/volantis-jp-style-css/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/20/volantis-jp-style-css/</id>
    <published>2025-06-20T08:00:00.000Z</published>
    <updated>2025-07-08T03:16:35.263Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建 Hexo 博客并使用 Volantis 主题的过程中，为了营造一种温柔、宁静、类似吉卜力风格的视觉效果，我进行了以下几个方面的样式调整和优化。</p><h2 id="顶栏样式调整"><a href="#顶栏样式调整" class="headerlink" title="顶栏样式调整"></a>顶栏样式调整</h2><p>将默认主题的顶栏背景色替换为柔和的奶油色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#l_header</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#e5ddc5</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接颜色调整"><a href="#链接颜色调整" class="headerlink" title="链接颜色调整"></a>链接颜色调整</h2><p>为了呼应整体的暖色调，同时保持良好的可读性和视觉反馈，设置了如下链接颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#3b7d99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#bb4d3b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模糊背景优化"><a href="#模糊背景优化" class="headerlink" title="模糊背景优化"></a>模糊背景优化</h2><p>Volantis 默认通过 <code>.blur</code> 类结合 <code>backdrop-filter</code> 添加半透明白色背景。为了贴近吉卜力风格，我将其调整为更温暖的色调：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blur</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">250</span>, <span class="number">245</span>, <span class="number">235</span>, <span class="number">0.9</span>) <span class="meta">!important</span>;  <span class="comment">/* 柔和奶油白 */</span></span><br><span class="line">  <span class="attribute">backdrop-filter</span>: <span class="built_in">saturate</span>(<span class="number">150%</span>) <span class="built_in">blur</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以让导航栏、顶部 cover 区域呈现柔光玻璃质感，更加温润不刺眼。</p><h2 id="全局背景色设置"><a href="#全局背景色设置" class="headerlink" title="全局背景色设置"></a>全局背景色设置</h2><p>为了让整个页面背景统一、温暖，采用柔和的奶油白作为主背景色，适用于页面主体、头部、底部等区域：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.page</span>,</span><br><span class="line"><span class="selector-class">.header</span>,</span><br><span class="line"><span class="selector-class">.footer</span>,</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff8e7</span> <span class="meta">!important</span>; <span class="comment">/* 奶油白 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景色覆盖说明：问题定位与排查过程"><a href="#背景色覆盖说明：问题定位与排查过程" class="headerlink" title="背景色覆盖说明：问题定位与排查过程"></a>背景色覆盖说明：问题定位与排查过程</h2><p>在设置 <code>body</code> 或 <code>article</code> 的背景色时，我遇到了一个问题：<strong>即使使用了 <code>!important</code>，设置的背景色依然无效</strong>，在 DevTools 中甚至会被划掉删除线。</p><p> 排查过程如下：</p><ol><li><p><strong>初步怀疑被其他类覆盖</strong>，尝试提升选择器优先级，如 <code>article.card</code>，仍然无效。</p></li><li><p><strong>观察 computed style</strong> 面板，发现真正生效的背景来自一个透明白的 <code>rgba</code> 值。<br> <img src="/../../../../images/screenshot/2025-06-23_15-08_volantis-jp-style-css.png" alt="computed style"></p></li><li><p>逐层审查 DOM，最终在 <code>.blur</code> 类上找到了这条规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blur</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Volantis 主题为了实现玻璃拟态效果而添加的样式。</p></li><li><p>确认该规则在支持 <code>backdrop-filter</code> 的浏览器中通过 <code>@supports</code> 被启用，并且优先级极高。</p></li><li><p>尝试对 <code>.blur</code> 使用新的背景覆盖，测试不同透明度、颜色组合后，最终选用 <code>rgba(250, 245, 235, 0.9)</code> 作为主色。</p></li><li><p>同时，为防止 <code>.blur</code> 遮盖全局背景，设置 <code>body</code>, <code>.page</code>, <code>.main</code> 等关键容器背景色统一为奶油白。</p></li></ol><hr><p>通过上述设置，一个风格统一、色彩柔和、具有吉卜力美感的博客界面就完成了。</p><p>如果你也想打造自己的特色博客风格，不妨从配色入手，加入些微动效与模糊处理，会让整体观感更加细腻舒适。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在搭建 Hexo 博客并使用 Volantis 主题的过程中，为了营造一种温柔、宁静、类似吉卜力风格的视觉效果，我进行了以下几个方面的样式调整和优化。&lt;/p&gt;
&lt;h2 id=&quot;顶栏样式调整&quot;&gt;&lt;a href=&quot;#顶栏样式调整&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="美化定制" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E7%BE%8E%E5%8C%96%E5%AE%9A%E5%88%B6/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="CSS" scheme="https://ai.he0xwhale.xyz/tags/CSS/"/>
    
    <category term="博客主题" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
    
    <category term="吉卜力" scheme="https://ai.he0xwhale.xyz/tags/%E5%90%89%E5%8D%9C%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客头像图片异常变回旧图的问题排查记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/20/hexo_avatar_bug/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/20/hexo_avatar_bug/</id>
    <published>2025-06-20T07:09:45.000Z</published>
    <updated>2025-07-08T03:16:28.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用 Hexo 搭建博客（主题为 Volantis）过程中，用户修改了博客头像路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span> <span class="string">/images/website/avatar.png</span></span><br></pre></td></tr></table></figure><p>原头像为旧图 <code>/images/logo_2.png</code>，已确认删除。但在使用 <code>hexo server</code> 启动后，首页初始加载时头像显示正常，一旦<strong>打开 Chrome DevTools 并刷新页面</strong>，头像却重新变回 <code>/images/logo_2.png</code>，尽管图片已被删除，且请求返回 404。<br><img src="/../../../../images/screenshot/2025-06-20_15-15_hexo_avatar_bug.png" alt="显示错误"></p><p><img src="/../../../../images/screenshot/2025-06-20_15-15_hexo_avatar_bug_2.png" alt="控制台报错"></p><hr><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="✅-配置方面"><a href="#✅-配置方面" class="headerlink" title="✅ 配置方面"></a>✅ 配置方面</h3><ul><li>清除 Hexo 缓存：<code>hexo clean &amp;&amp; hexo g</code></li><li>删除 <code>public/</code>、<code>.cache/</code>、<code>db.json</code></li><li>确认 <code>themes/volantis/_config.yml</code> 中 <code>widgets.blogger.avatar</code> 设置正确</li><li>确认模板文件 <code>blogger.ejs</code> 中渲染了正确路径</li><li>使用固定路径 <code>&lt;img src=&quot;/images/website/avatar.png&quot; /&gt;</code> 确保非变量问题</li></ul><h3 id="✅-运行时调试"><a href="#✅-运行时调试" class="headerlink" title="✅ 运行时调试"></a>✅ 运行时调试</h3><ul><li>使用 Firefox 正常，问题仅在 Chrome DevTools 下复现</li><li>DevTools 开启前头像正确，开启后刷新页面出现问题</li><li>尝试了 Break on → Attribute modifications，无效</li><li>控制台无 JS 报错，无 fallback 行为日志</li><li><code>document.querySelector(&#39;.avatar img&#39;).src</code> 被动变为旧图</li><li>请求图片地址状态码为 404，但仍被请求</li></ul><h3 id="✅-判断结果"><a href="#✅-判断结果" class="headerlink" title="✅ 判断结果"></a>✅ 判断结果</h3><p>此现象<strong>并非 Hexo 模板或输出问题</strong>，而是 Chrome DevTools 打开时触发了某种缓存&#x2F;快照机制，例如：</p><ul><li>Memory Cache</li><li>Back&#x2F;Forward Cache（bfcache）</li><li>离线快照还原（某些版本 DevTools 有此行为）</li></ul><p>这些机制会在刷新时“还原”旧 DOM 结构，或尝试访问旧图片路径，导致配置失效假象。</p><hr><h2 id="推荐的分析方法"><a href="#推荐的分析方法" class="headerlink" title="推荐的分析方法"></a>推荐的分析方法</h2><ol><li><code>grep</code> 分析 Hexo 输出 HTML：确认没有旧图引用</li><li><code>curl</code> 拉取页面源码，跳过浏览器行为确认 HTML 是否干净</li><li>使用 Puppeteer 加载页面，分析 DOM 实际渲染头像路径</li><li>使用 DevTools Performance 追踪是否有 JS 篡改 DOM</li><li>使用 MutationObserver 实时监控 <code>img[src]</code> 是否被改写</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> avatarImg = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.avatar img&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="property">attributeName</span> === <span class="string">&#x27;src&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;[MutationObserver] src changed to:&#x27;</span>, avatarImg.<span class="property">src</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">trace</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(avatarImg, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h2><p>由于问题可能来自浏览器的复杂缓存机制，短期内无法完全复现和修复，因此决定先不继续深究，保留此记录供未来参考。也欢迎大家留言共同讨论该问题</p><hr><h2 id="建议与避坑技巧"><a href="#建议与避坑技巧" class="headerlink" title="建议与避坑技巧"></a>建议与避坑技巧</h2><ul><li>所有头像&#x2F;图片路径建议添加查询参数：<code>?v=20250619</code> 避免缓存</li><li><code>hexo clean &amp;&amp; rm -rf public/</code> 是每次改图后的标准操作</li><li>DevTools 开启时务必勾选 <code>Disable cache</code></li><li><code>widgets.index/page/mobile</code> 均应显式设置 <code>avatar</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在使用 Hexo 搭建博客（主题为 Volantis）过程中，用户修改了博客头像路径：&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="前端调试" scheme="https://ai.he0xwhale.xyz/tags/%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从 Hexo 模板创建新博客并独立管理 Volantis 子模块的完整过程</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/19/hexo_submodule_split_blog/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/19/hexo_submodule_split_blog/</id>
    <published>2025-06-19T06:52:18.000Z</published>
    <updated>2025-07-08T03:16:21.991Z</updated>
    
    <content type="html"><![CDATA[<p>在 Hexo 博客搭建中，很多用户会选择将主题如 Volantis 作为子模块管理以便于后续更新。然而，如果你想以现有的博客为模板创建新的博客，并保留主题改动，同时又不希望多个项目之间相互干扰，合理管理 Git 子模块就显得非常重要。</p><p>本文记录了一个完整的实践过程，包含遇到的问题、原因分析和最终的解决方法。</p><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><ul><li>已有博客项目：<code>ai_blog</code>，使用 fork 的 Volantis 主题作为 Git 子模块，且 <code>_config.yml</code> 中做了大量定制修改；</li><li>目标：创建一个新博客 <code>tech_blog</code>，以 <code>ai_blog</code> 为基础模板，但希望主题配置独立；</li><li>遇到的问题包括：子模块复用导致冲突、分支不同步、远程混乱、推送失败等。</li></ul><hr><h2 id="一、从模板创建新项目"><a href="#一、从模板创建新项目" class="headerlink" title="一、从模板创建新项目"></a>一、从模板创建新项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆 ai_blog，包括子模块</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/yourname/ai_blog.git tech_blog</span><br><span class="line"><span class="built_in">cd</span> tech_blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧 git 记录，准备建立新仓库</span></span><br><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新添加远程并提交</span></span><br><span class="line">git remote add origin https://github.com/yourname/tech_blog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;初始化 tech_blog&quot;</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><hr><h2 id="二、Volantis-主题子模块独立化"><a href="#二、Volantis-主题子模块独立化" class="headerlink" title="二、Volantis 主题子模块独立化"></a>二、Volantis 主题子模块独立化</h2><h3 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h3><p>多个项目共享同一个 fork 的主题仓库，如果任意一个项目修改了 <code>_config.yml</code> 并 <code>push</code>，会影响其他项目。</p><h3 id="解决方案：为新博客单独创建-volantis-tech-仓库"><a href="#解决方案：为新博客单独创建-volantis-tech-仓库" class="headerlink" title="解决方案：为新博客单独创建 volantis-tech 仓库"></a>解决方案：为新博客单独创建 volantis-tech 仓库</h3><ol><li><p>首先在github上创建新的空白仓库：volantis-tech</p></li><li><p>再执行下面的命令</p><pre><code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 克隆 volantis 源仓库</span></span><br><span class="line"></span><br><span class="line"> git <span class="built_in">clone</span> --bare https://github.com/yourname/volantis.git volantis-bare</span><br><span class="line"> <span class="built_in">cd</span> volantis-bare</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送为新仓库</span></span><br><span class="line"></span><br><span class="line"> git push --mirror https://github.com/yourname/volantis-tech.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">cd</span> ..</span><br><span class="line"> <span class="built_in">rm</span> -rf volantis-bare</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 三、彻底移除旧子模块并添加新主题</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 移除旧子模块引用</span><br><span class="line">git submodule deinit -f themes/volantis</span><br><span class="line">git rm -f themes/volantis</span><br><span class="line">rm -rf .git/modules/themes/volantis</span><br><span class="line">rm -rf themes/volantis</span><br><span class="line">rm -f .gitmodules</span><br><span class="line"></span><br><span class="line"># 添加新的 volantis-tech 作为子模块</span><br><span class="line">git submodule add https://github.com/yourname/volantis-tech.git themes/volantis</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="四、关于-config-yml-修改后未生效的问题"><a href="#四、关于-config-yml-修改后未生效的问题" class="headerlink" title="四、关于 _config.yml 修改后未生效的问题"></a>四、关于 <code>_config.yml</code> 修改后未生效的问题</h2><blockquote><p>修改了 <code>themes/volantis/_config.yml</code>，但 GitHub 页面没有变化？</p></blockquote><p>这是因为 Volantis 是子模块，其更改需要进入子模块内部手动提交和推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/volantis</span><br><span class="line">git checkout -b custom-fontawesome</span><br><span class="line">git add _config.yml</span><br><span class="line">git commit -m <span class="string">&quot;修改配置&quot;</span></span><br><span class="line">git push --set-upstream origin custom-fontawesome</span><br></pre></td></tr></table></figure><p>然后回到主项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line">git add themes/volantis</span><br><span class="line">git commit -m <span class="string">&quot;更新子模块引用&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><hr><h2 id="五、解决-git-push-报错问题"><a href="#五、解决-git-push-报错问题" class="headerlink" title="五、解决 git push 报错问题"></a>五、解决 <code>git push</code> 报错问题</h2><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: 当前分支 main 没有对应的上游分支。</span><br></pre></td></tr></table></figure><p>解决方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin main</span><br></pre></td></tr></table></figure><hr><h2 id="六、其他注意事项"><a href="#六、其他注意事项" class="headerlink" title="六、其他注意事项"></a>六、其他注意事项</h2><ul><li><code>.git/modules/</code> 是 Git 存放子模块缓存数据的地方，必须清除干净；</li><li>使用多个项目共用子模块时，应考虑使用不同分支，或完全复制主题；</li><li>如果不能再 fork 自己的仓库，可以用 <code>git clone --bare</code> + <code>git push --mirror</code> 方案手动创建副本。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次实践，我们完整演示了如何从已有 Hexo 项目中派生一个新项目，并妥善管理子模块以避免多个项目间的冲突。推荐在多个博客中使用 fork + 分支方式隔离配置，确保互不干扰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Hexo 博客搭建中，很多用户会选择将主题如 Volantis 作为子模块管理以便于后续更新。然而，如果你想以现有的博客为模板创建新的博客，并保留主题改动，同时又不希望多个项目之间相互干扰，合理管理 Git 子模块就显得非常重要。&lt;/p&gt;
&lt;p&gt;本文记录了一个完整的实践</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="Git" scheme="https://ai.he0xwhale.xyz/tags/Git/"/>
    
    <category term="Git Submodule" scheme="https://ai.he0xwhale.xyz/tags/Git-Submodule/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中添加字数统计功能出现标题解析异常的排查记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/18/hexo-wordcount-bugfix/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/18/hexo-wordcount-bugfix/</id>
    <published>2025-06-18T03:10:00.000Z</published>
    <updated>2025-07-08T03:16:49.174Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在为 Hexo 博客集成字数统计功能时，我遇到一个渲染异常的问题：一段普通的文字和其后的图片被误解析为标题（<code>&lt;h2&gt;</code> 标签），导致显示错乱。这篇文章记录了该问题的排查和解决过程，供遇到类似情况的朋友参考。</p></blockquote><h2 id="一、背景与问题描述"><a href="#一、背景与问题描述" class="headerlink" title="一、背景与问题描述"></a>一、背景与问题描述</h2><p>我为 Hexo 博客安装了 <code>hexo-wordcount</code> 插件，并使用 Volantis 主题。在配置 <code>top_meta</code> 后，字数统计功能成功显示。但在文章中记录成功效果时，出现如下异常渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;最终，在文章标题下方正确显示了字数统计和阅读时长信息。&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原因是如下 Markdown 被错误渲染为一个标题标签：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最终，在文章标题下方正确显示了字数统计和阅读时长信息。</span><br><span class="line">![<span class="string">wordcount</span>](<span class="link">../../../../images/screenshot/2025-06-13_11-18_wordcount.png</span>)</span><br></pre></td></tr></table></figure><h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><p>这一问题的根本原因在于 Markdown 渲染器（如 <code>hexo-renderer-marked</code> 或 <code>markdown-it</code>）在处理<strong>文字段落紧跟图片</strong>的语法时，某些情况下可能会将其视为同一个段落，并错误地转换为标题。</p><p>特别是在前一行末尾为句号或中文符号，下一行又是图片语法（<code>![...](...)</code>），更容易被误判。</p><h2 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h2><h3 id="✅-方法一：添加空行"><a href="#✅-方法一：添加空行" class="headerlink" title="✅ 方法一：添加空行"></a>✅ 方法一：添加空行</h3><p>最简单直接的方式是在文字和图片之间添加空行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最终，在文章标题下方正确显示了字数统计和阅读时长信息。</span><br><span class="line"></span><br><span class="line">![<span class="string">wordcount</span>](<span class="link">../../../../images/screenshot/2025-06-13_11-18_wordcount.png</span>)</span><br></pre></td></tr></table></figure><p>这样就能明确告诉 Markdown 渲染器，两者为<strong>独立段落</strong>，避免误合并。</p><h3 id="✅-方法二：使用-HTML-显式结构"><a href="#✅-方法二：使用-HTML-显式结构" class="headerlink" title="✅ 方法二：使用 HTML 显式结构"></a>✅ 方法二：使用 HTML 显式结构</h3><p>如果你希望行为更可控，也可以使用 HTML 标签来书写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>最终，在文章标题下方正确显示了字数统计和阅读时长信息。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/screenshot/2025-06-13_11-18_wordcount.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;wordcount&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>适用于结构化或需要稳定渲染效果的写作场景。</p><h2 id="四、推荐做法"><a href="#四、推荐做法" class="headerlink" title="四、推荐做法"></a>四、推荐做法</h2><p>如果你经常写文章涉及图片展示，建议：</p><ul><li>保持图片前后有空行，避免粘连；</li><li>为每段落标题单独一行，加空行隔开；</li><li>避免中文段落结尾紧贴 Markdown 图片语法；</li><li>也可视情况用 HTML 标签规避解析器差异。</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Markdown 的“简洁”语法有时也容易出现歧义。在 Hexo + Volantis 环境中，特别是涉及插件渲染和主题模板的场景，更需要小心结构布局。希望本文对你遇到类似问题时有所帮助。</p><hr><p>如果你在 Hexo 使用过程中也遇到其他类似问题，欢迎留言交流 🙌。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在为 Hexo 博客集成字数统计功能时，我遇到一个渲染异常的问题：一段普通的文字和其后的图片被误解析为标题（&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; 标签），导致显示错乱。这篇文章记录了该问题的排查和解决过程，供遇到类似情况的朋友参考。&lt;/p</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="Markdown" scheme="https://ai.he0xwhale.xyz/tags/Markdown/"/>
    
    <category term="Bug排查" scheme="https://ai.he0xwhale.xyz/tags/Bug%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>用 Cursor 开发 VSCode 插件时遇到的版本兼容性问题排查实录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/17/vscode-cursor-plugin-issue/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/17/vscode-cursor-plugin-issue/</id>
    <published>2025-06-17T06:13:00.000Z</published>
    <updated>2025-06-17T06:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode-插件在-Cursor-不能用？一次环境兼容性大坑的排查与解决"><a href="#VSCode-插件在-Cursor-不能用？一次环境兼容性大坑的排查与解决" class="headerlink" title="VSCode 插件在 Cursor 不能用？一次环境兼容性大坑的排查与解决"></a>VSCode 插件在 Cursor 不能用？一次环境兼容性大坑的排查与解决</h1><p>最近在开发 VSCode 插件时，遇到了一个非常隐蔽但又很有代表性的大坑：插件在官方 VSCode 客户端中一切正常，但在 Cursor 编辑器中死活激活不了，命令也不显示。</p><p>这篇文章记录我的排查过程、最终的解决办法，以及一些经验教训，希望能帮到遇到类似问题的你。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我写了一个 VSCode 插件，在官方 VSCode 客户端里可以正常激活和使用，命令也能正常显示。<br>但当我切换到 Cursor 编辑器，发现插件根本没有被激活，命令也找不到。</p><p>我反复检查代码、配置，依赖也都装了，编译也没报错，就是不行！</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="1-常规排查"><a href="#1-常规排查" class="headerlink" title="1. 常规排查"></a>1. 常规排查</h3><ul><li>重新安装依赖（<code>pnpm install</code>）</li><li>重新编译（<code>pnpm run compile</code>）</li><li>检查 <code>package.json</code> 配置</li><li>查看输出面板和调试控制台</li></ul><p>结果都没有发现明显问题。</p><h3 id="2-环境对比（真实心路）"><a href="#2-环境对比（真实心路）" class="headerlink" title="2. 环境对比（真实心路）"></a>2. 环境对比（真实心路）</h3><p>其实在排查过程中，我并没有第一时间注意到 VSCode 和 Cursor 的底层版本差异。<br>一开始只是觉得它们界面很像，理所当然地以为插件兼容性不会有大问题。</p><p>直到我在向 ChatGPT 提问、查找资料时，AI 给出的参考链接里，有一位开发者在论坛帖子中提到了 Cursor 的 VSCode 版本和 package.json 里声明的版本不一致，我才恍然大悟！</p><h3 id="3-灵感来源"><a href="#3-灵感来源" class="headerlink" title="3. 灵感来源"></a>3. 灵感来源</h3><p>这个帖子真的救了我一命：<a href="">How to debug a VS Code extension using CursorAI</a></p><p>他们的解决办法是：<br>把 <code>package.json</code> 里的 vscode 版本降级到 Cursor 支持的版本，比如 <code>^1.93.0</code>，然后重新装依赖、重新编译，插件就能用了！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>修改 package.json：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;engines&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;vscode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.93.0&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>同步修改 <code>@types/vscode</code> 依赖版本为 <code>^1.93.0</code></p></li><li><p>重新安装依赖：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install</span><br></pre></td></tr></table></figure><ol start="4"><li>重新编译：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm run compile</span><br></pre></td></tr></table></figure><p>重启 Cursor，插件终于能正常激活了！</p><h2 id="经验与建议"><a href="#经验与建议" class="headerlink" title="经验与建议"></a>经验与建议</h2><ul><li>环境兼容性问题很隐蔽，尤其是 VSCode 插件开发，别只盯着代码，环境和依赖版本也很关键！</li><li>遇到问题多去官方论坛、社区搜一搜，有时候一句话就能救你一天。</li><li>提问时尽量描述清楚环境差异和具体表现，这样更容易获得有用的答案。</li><li>很多时候，我们并不是靠自己一步步推理出来的，而是通过社区、AI、搜索引擎等外部信息，才发现了问题的本质。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="">How to debug a VS Code extension using CursorAI</a></li></ul><p>如果你也遇到类似问题，欢迎在评论区留言交流！</p><p><strong>希望这篇文章能帮你少走弯路！</strong></p><p><em>如需进一步交流，欢迎关注我的频道&#x2F;博客，后续会持续分享更多开发实战经验！</em></p>]]></content>
    
    
    <summary type="html">记录一次用 Cursor 开发 VSCode 插件时遇到的环境兼容性问题、排查过程与解决方案，帮助开发者少走弯路。</summary>
    
    
    
    <category term="技术分享" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="开发实战" scheme="https://ai.he0xwhale.xyz/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="VSCode" scheme="https://ai.he0xwhale.xyz/tags/VSCode/"/>
    
    <category term="Cursor" scheme="https://ai.he0xwhale.xyz/tags/Cursor/"/>
    
    <category term="插件开发" scheme="https://ai.he0xwhale.xyz/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="踩坑记录" scheme="https://ai.he0xwhale.xyz/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客结构化数据与 SEO 配置实践全记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/17/hexo_seo_debug_guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/17/hexo_seo_debug_guide/</id>
    <published>2025-06-17T02:43:01.000Z</published>
    <updated>2025-07-08T03:17:05.774Z</updated>
    
    <content type="html"><![CDATA[<p>最近对 Hexo 博客进行了结构化数据（Structured Data）与 SEO 配置优化，过程中踩了不少坑，以下是完整的记录与总结，希望对同样使用 Hexo 的朋友有所帮助。</p><h2 id="一、起因：Search-Console-无法检测结构化数据"><a href="#一、起因：Search-Console-无法检测结构化数据" class="headerlink" title="一、起因：Search Console 无法检测结构化数据"></a>一、起因：Search Console 无法检测结构化数据</h2><p>起初在 Google 的 Rich Results 测试工具和 Search Console 中发现博客页面无法识别任何结构化数据，怀疑是结构化数据输出有误。</p><h2 id="二、排查过程与问题定位"><a href="#二、排查过程与问题定位" class="headerlink" title="二、排查过程与问题定位"></a>二、排查过程与问题定位</h2><h3 id="1-替换-schema-org-cn-为-schema-org"><a href="#1-替换-schema-org-cn-为-schema-org" class="headerlink" title="1. 替换 schema.org.cn 为 schema.org"></a>1. 替换 schema.org.cn 为 schema.org</h3><p>在检查页面源代码后发现结构化数据的 <code>@context</code> 字段中使用了 <code>https://schema.org.cn</code>，而 Google 仅识别 <code>https://schema.org</code>，于是批量替换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/schema\.org\.cn/schema.org/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>修改后重新部署，Rich Results 测试开始可以正常识别结构化数据。但具体是因为该原因还是只是延迟导致的，还没有完全确定。</p><h3 id="2-Search-Console-仍无索引"><a href="#2-Search-Console-仍无索引" class="headerlink" title="2. Search Console 仍无索引"></a>2. Search Console 仍无索引</h3><p>虽然 Rich Results 工具成功检测，但 Search Console 中依然没有任何结构化数据结果。考虑可能是 Google 尚未重新抓取，决定暂时不再深究。</p><h2 id="三、SEO-配置优化建议（基础-Open-Graph-Structured-Data）"><a href="#三、SEO-配置优化建议（基础-Open-Graph-Structured-Data）" class="headerlink" title="三、SEO 配置优化建议（基础 + Open Graph + Structured Data）"></a>三、SEO 配置优化建议（基础 + Open Graph + Structured Data）</h2><h3 id="（1）基础-SEO-设置"><a href="#（1）基础-SEO-设置" class="headerlink" title="（1）基础 SEO 设置"></a>（1）基础 SEO 设置</h3><h4 id="keywords-配置"><a href="#keywords-配置" class="headerlink" title="keywords 配置"></a>keywords 配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">use_tags_as_keywords:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>建议在首页或重要页面额外加上 front-matter 中的 <code>keywords</code> 字段，并限制关键词数量（推荐 5–10 个）以避免关键词堆砌。</p><h4 id="description-描述"><a href="#description-描述" class="headerlink" title="description 描述"></a>description 描述</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">use_excerpt_as_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>摘要需控制在 150–160 字，建议重要页面手动设置 <code>description</code>，可加入品牌词、核心亮点。</p><h4 id="robots-设置"><a href="#robots-设置" class="headerlink" title="robots 设置"></a>robots 设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">home_first_page:</span> <span class="string">index,follow</span></span><br><span class="line"><span class="attr">home_other_pages:</span> <span class="string">noindex,follow</span></span><br><span class="line"><span class="attr">archive:</span> <span class="string">noindex,follow</span></span><br><span class="line"><span class="attr">category:</span> <span class="string">noindex,follow</span></span><br><span class="line"><span class="attr">tag:</span> <span class="string">noindex,follow</span></span><br></pre></td></tr></table></figure><p>若分页&#x2F;分类&#x2F;标签页确实有价值内容，可将其调整为 <code>index,follow</code>。</p><h4 id="sitemap-xml-配置"><a href="#sitemap-xml-配置" class="headerlink" title="sitemap.xml 配置"></a>sitemap.xml 配置</h4><p>确保安装并正确配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>并在 <code>robots.txt</code> 中声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sitemap: https://your-domain.com/sitemap.xml</span><br></pre></td></tr></table></figure><h4 id="canonical-链接"><a href="#canonical-链接" class="headerlink" title="canonical 链接"></a>canonical 链接</h4><p>建议启用，避免重复页面影响权重。</p><h3 id="（2）Open-Graph-社交分享"><a href="#（2）Open-Graph-社交分享" class="headerlink" title="（2）Open Graph 社交分享"></a>（2）Open Graph 社交分享</h3><h4 id="默认图片"><a href="#默认图片" class="headerlink" title="默认图片"></a>默认图片</h4><p><code>open_graph.image</code> 建议使用完整 URL，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">open_graph:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">https://cdn.jsdelivr.net/gh/your-repo/img/android-chrome-192x192.png</span></span><br></pre></td></tr></table></figure><h4 id="Twitter-类型"><a href="#Twitter-类型" class="headerlink" title="Twitter 类型"></a>Twitter 类型</h4><p>如果文章有大封面图，建议使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">twitter_card_type:</span> <span class="string">summary_large_image</span></span><br></pre></td></tr></table></figure><h4 id="Twitter-ID"><a href="#Twitter-ID" class="headerlink" title="Twitter ID"></a>Twitter ID</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">twitter_id:</span> <span class="string">&quot;@your_id&quot;</span></span><br><span class="line"><span class="attr">twitter_site:</span> <span class="string">&quot;@your_site&quot;</span></span><br></pre></td></tr></table></figure><h3 id="（3）Structured-Data-结构化数据"><a href="#（3）Structured-Data-结构化数据" class="headerlink" title="（3）Structured Data 结构化数据"></a>（3）Structured Data 结构化数据</h3><p>已启用类型：BlogPosting、BreadcrumbList、Organization、Person、Website。</p><p>建议确认以下字段输出完整：</p><ul><li>headline</li><li>datePublished</li><li>dateModified</li><li>mainEntityOfPage</li><li>author.name</li><li>publisher.logo</li></ul><h4 id="组织信息-Organization"><a href="#组织信息-Organization" class="headerlink" title="组织信息 Organization"></a>组织信息 Organization</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">structured_data:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">organization:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;Your Brand&quot;</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">&quot;https://your-domain.com&quot;</span></span><br><span class="line">      <span class="attr">sameAs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;https://twitter.com/your_brand&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;https://github.com/your_brand&quot;</span></span><br></pre></td></tr></table></figure><h4 id="作者信息-Person"><a href="#作者信息-Person" class="headerlink" title="作者信息 Person"></a>作者信息 Person</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">&quot;https://your-domain.com/about&quot;</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">&quot;https://your-domain.com/img/avatar.png&quot;</span></span><br></pre></td></tr></table></figure><h2 id="四、Search-Console-报错-sitemap-xml-“Couldn’t-fetch”-的解决"><a href="#四、Search-Console-报错-sitemap-xml-“Couldn’t-fetch”-的解决" class="headerlink" title="四、Search Console 报错 sitemap.xml “Couldn’t fetch” 的解决"></a>四、Search Console 报错 sitemap.xml “Couldn’t fetch” 的解决</h2><p>在 Search Console 添加 sitemap.xml 时出现 “Couldn’t fetch” 报错，但直接访问如 <code>https://ai.example.xyz/sitemap.xml</code> 却正常。</p><p>排查后确认是插件未安装导致未生成 sitemap 文件。解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>然后重新部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>再次提交 sitemap 即可正常解析。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>通过上述一系列配置与排查，博客的结构化数据已能被 Google 正确识别，同时也梳理了 SEO 的相关策略，包括关键词、摘要、社交分享优化等。</p><p>建议所有 Hexo 用户结合自己内容情况进行适度调整，重点关注 sitemap 输出、结构化数据 schema 正确性、以及 Meta 标签内容丰富性。</p><p>祝各位博客 SEO 提升顺利！</p>]]></content>
    
    
    <summary type="html">记录一次围绕 Hexo 博客中结构化数据配置、排错与 SEO 基础策略完善的全过程实践，涵盖关键词策略、社交分享、Google Rich Results 测试等内容。</summary>
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="优化推广" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E4%BC%98%E5%8C%96%E6%8E%A8%E5%B9%BF/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="SEO" scheme="https://ai.he0xwhale.xyz/tags/SEO/"/>
    
    <category term="OpenGraph" scheme="https://ai.he0xwhale.xyz/tags/OpenGraph/"/>
    
    <category term="结构化数据" scheme="https://ai.he0xwhale.xyz/tags/%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/"/>
    
    <category term="搜索引擎优化" scheme="https://ai.he0xwhale.xyz/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中添加字数统计功能的实践记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/13/hexo-wordcount-practice/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/13/hexo-wordcount-practice/</id>
    <published>2025-06-13T02:49:18.000Z</published>
    <updated>2025-07-08T03:17:35.006Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建 Hexo 博客并使用 Volantis 主题时，我尝试为文章添加字数统计功能。以下是我在此过程中遇到的问题和最终解决方案的完整记录。</p><h2 id="一、安装插件与初始配置"><a href="#一、安装插件与初始配置" class="headerlink" title="一、安装插件与初始配置"></a>一、安装插件与初始配置</h2><p>我按照_config.yml中说明的，安装了 <code>hexo-wordcount</code> 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-wordcount</span><br></pre></td></tr></table></figure><p>并在博客volantis主题目录下的 <code>_config.yml</code> 文件中进行了如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="comment"># ...(省略)</span></span><br><span class="line">  <span class="attr">wordcount:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>并运行以下命令以重建博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h2 id="二、发现没有生效"><a href="#二、发现没有生效" class="headerlink" title="二、发现没有生效"></a>二、发现没有生效</h2><p>尽管配置无误，且 <code>hexo-wordcount</code> 插件安装成功，但在本地启动博客预览时，文章标题下方并未显示任何字数统计信息。</p><h2 id="三、逐步排查"><a href="#三、逐步排查" class="headerlink" title="三、逐步排查"></a>三、逐步排查</h2><h3 id="1-检查-article-ejs"><a href="#1-检查-article-ejs" class="headerlink" title="1. 检查 article.ejs"></a>1. 检查 <code>article.ejs</code></h3><p>首先我查看了主题路径下的 <code>themes/volantis/layout/_partial/article.ejs</code>，发现其通过 <code>&lt;%- partial(&#39;meta&#39;, &#123;post: post, position: &#39;top&#39;&#125;) %&gt;</code> 引用了 <code>meta.ejs</code> 文件，即所有顶栏信息都来源于该处。</p><h3 id="2-查看-meta-ejs"><a href="#2-查看-meta-ejs" class="headerlink" title="2. 查看 meta.ejs"></a>2. 查看 <code>meta.ejs</code></h3><p>继续跟踪到 <code>themes/volantis/layout/_partial/meta.ejs</code>，该文件通过如下逻辑决定顶部信息的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% getList(topMetas).forEach(function(meta) &#123; %&gt;</span><br><span class="line">  &lt;% if (meta in theme.article.body.meta_library)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#x27;../_meta/&#x27; + meta, &#123;post: post&#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br></pre></td></tr></table></figure><p>说明真正负责渲染字数统计的代码位于 <code>themes/volantis/layout/_meta/wordcount.ejs</code> 文件。</p><h3 id="3-找到字数统计渲染模板"><a href="#3-找到字数统计渲染模板" class="headerlink" title="3. 找到字数统计渲染模板"></a>3. 找到字数统计渲染模板</h3><p>我找到了该文件，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.plugins.wordcount.enable) &#123; %&gt;</span><br><span class="line">  &lt;div class=&quot;new-meta-item wordcount&quot;&gt;</span><br><span class="line">    &lt;a class=&#x27;notlink&#x27;&gt;</span><br><span class="line">      &lt;i class=&quot;&lt;%- theme.article.body.meta_library.wordcount.icon_wordcount %&gt; fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;p&gt;&lt;%- __(&#x27;post.wordcount&#x27;, wordcount(post.content))%&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;new-meta-item readtime&quot;&gt;</span><br><span class="line">    &lt;a class=&#x27;notlink&#x27;&gt;</span><br><span class="line">      &lt;i class=&quot;&lt;%- theme.article.body.meta_library.wordcount.icon_duration %&gt; fa-fw&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;p&gt;&lt;%- __(&#x27;post.duration&#x27;, min2read(post.content))%&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>模板存在，配置也没报错，为什么就是不显示呢？</p><h2 id="四、真正的原因"><a href="#四、真正的原因" class="headerlink" title="四、真正的原因"></a>四、真正的原因</h2><p>查看和AI的对话，我注意到了top_meta这个配置项，最终我意识到问题出在一个不起眼的配置项：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="attr">article:</span></span><br><span class="line">    <span class="attr">body:</span></span><br><span class="line">      <span class="attr">top_meta:</span> [<span class="string">author</span>, <span class="string">category</span>, <span class="string">date</span>, <span class="string">wordcount</span>, <span class="string">counter</span>]</span><br></pre></td></tr></table></figure><p>在我的原始配置中，并未在 <code>top_meta</code> 中包含 <code>wordcount</code>，所以尽管一切准备就绪，模板中没有调用它，自然就不会渲染出来。</p><h2 id="五、成功显示"><a href="#五、成功显示" class="headerlink" title="五、成功显示"></a>五、成功显示</h2><p>添加了 <code>wordcount</code> 到 <code>top_meta</code> 列表后，再次运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>最终，在文章标题下方正确显示了字数统计和阅读时长信息：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../../../../images/screenshot/2025-06-13_11-18_wordcount.png" alt="wordcount"></h2><p>至此，字数统计功能成功集成。如果你也遇到类似问题，可以从以下几点排查：</p><ul><li>插件是否正确安装</li><li><code>_config.yml</code> 中是否启用了 <code>wordcount</code></li><li><code>top_meta</code> 中是否包含 <code>wordcount</code></li><li>模板文件是否存在 <code>wordcount.ejs</code></li></ul><p>希望这篇文章能帮到你。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在搭建 Hexo 博客并使用 Volantis 主题时，我尝试为文章添加字数统计功能。以下是我在此过程中遇到的问题和最终解决方案的完整记录。&lt;/p&gt;
&lt;h2 id=&quot;一、安装插件与初始配置&quot;&gt;&lt;a href=&quot;#一、安装插件与初始配置&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="字数统计" scheme="https://ai.he0xwhale.xyz/tags/%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中为文章添加封面图的实践记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/12/hexo-cover-image-practice/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/12/hexo-cover-image-practice/</id>
    <published>2025-06-12T07:00:00.000Z</published>
    <updated>2025-07-08T03:16:13.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>在搭建 Hexo 博客的过程中，我一直希望文章列表能更美观一些。特别是首页的文章卡片，如果能加上一张封面图，整体效果会更加吸引人。于是我着手尝试为文章添加封面图，并记录下这个过程，希望对同样使用 Volantis 主题的朋友有所帮助。</p><h2 id="2-封面图功能的支持背景"><a href="#2-封面图功能的支持背景" class="headerlink" title="2. 封面图功能的支持背景"></a>2. 封面图功能的支持背景</h2><p>我使用的是 Hexo + Volantis 主题，发现主题的文章预览卡片中，实际上是支持封面图显示的。只是这一功能并不默认开启，也没有在文档中有明显说明，需要我们自己手动配置。</p><p>在文章的 front-matter 中加入headimg字段，就可以控制每篇文章的封面图显示。</p><h2 id="3-添加封面图的方法"><a href="#3-添加封面图的方法" class="headerlink" title="3. 添加封面图的方法"></a>3. 添加封面图的方法</h2><p>在每篇 Markdown 文章的开头（也就是 front-matter 区域），添加 <code>headimg</code> 字段即可。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 博客封面图测试</span><br><span class="line">date: 2025-06-10 16:20:00</span><br><span class="line">tags:</span><br><span class="line">  - 博客测试</span><br><span class="line">cover: /images/test-cover.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure><blockquote><p>💡 图片路径推荐放在 <code>source/images/</code> 目录中，发布后可通过 <code>/images/xxx.jpg</code> 的形式引用。</p></blockquote><h2 id="4-封面图排查与验证过程"><a href="#4-封面图排查与验证过程" class="headerlink" title="4. 封面图排查与验证过程"></a>4. 封面图排查与验证过程</h2><p>一开始，我在文章中添加了 <code>cover</code> 字段，却没有显示封面图。于是我开始了排查过程：</p><h3 id="4-1-从-layout-开始追查"><a href="#4-1-从-layout-开始追查" class="headerlink" title="4.1 从 layout 开始追查"></a>4.1 从 layout 开始追查</h3><p>我打开了主题中的 <code>layout/index.ejs</code> 文件，发现它引用了 <code>_partial/archive</code> 模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#x27;_partial/archive&#x27;) %&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-查看-partial-archive-ejs"><a href="#4-2-查看-partial-archive-ejs" class="headerlink" title="4.2 查看 _partial&#x2F;archive.ejs"></a>4.2 查看 _partial&#x2F;archive.ejs</h3><p>在 <code>archive.ejs</code> 中，每一篇文章都通过如下方式渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#x27;post&#x27;, &#123;post: post&#125;) %&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-最终定位到-post-ejs"><a href="#4-3-最终定位到-post-ejs" class="headerlink" title="4.3 最终定位到 post.ejs"></a>4.3 最终定位到 post.ejs</h3><p>在 <code>post.ejs</code> 中，我看到了如下片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (post.headimg) &#123; %&gt;</span><br><span class="line">  &lt;img src=&quot;&lt;%- post.headimg %&gt;&quot; ... /&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>这时候我才意识到，原来 Volantis 主题是通过 <code>headimg</code> 字段来识别封面图的。</p><p>于是我把 front-matter 中的 <code>cover</code> 改成了 <code>headimg</code>，问题就解决了！</p><h2 id="5-最终效果与小结"><a href="#5-最终效果与小结" class="headerlink" title="5. 最终效果与小结"></a>5. 最终效果与小结</h2><p>现在，我的博客首页已经成功地为每篇文章展示封面图了。效果如下：<br><img src="/../images/headimg_add.png" alt="增加了文章封面图"></p><ul><li>图片大小自动适配卡片宽度</li><li>支持本地图片引用（推荐放到 <code>source/images/</code> 目录）</li><li>不需要修改任何模板，只需配置 <code>headimg</code> 字段即可</li></ul><h3 id="5-1-使用建议"><a href="#5-1-使用建议" class="headerlink" title="5.1 使用建议"></a>5.1 使用建议</h3><ul><li>每篇文章的封面图尽量统一尺寸，保持视觉一致性</li><li>可以使用 Gork、Canva 等工具快速生成封面图</li><li>如果有自动化需求，也可以结合脚本为旧文章批量添加封面字段</li></ul><p>希望这篇记录对你有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-写在前面&quot;&gt;&lt;a href=&quot;#1-写在前面&quot; class=&quot;headerlink&quot; title=&quot;1. 写在前面&quot;&gt;&lt;/a&gt;1. 写在前面&lt;/h2&gt;&lt;p&gt;在搭建 Hexo 博客的过程中，我一直希望文章列表能更美观一些。特别是首页的文章卡片，如果能加上一张封面</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="博客封面图" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2%E5%9B%BE/"/>
    
    <category term="实践记录" scheme="https://ai.he0xwhale.xyz/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中插入本地图片的实践记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/11/markdown_add_image/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/11/markdown_add_image/</id>
    <published>2025-06-11T09:00:00.000Z</published>
    <updated>2025-07-08T03:17:21.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🗃️-图片存放位置的选择"><a href="#🗃️-图片存放位置的选择" class="headerlink" title="🗃️ 图片存放位置的选择"></a>🗃️ 图片存放位置的选择</h2><p>我将图片统一放在了博客项目的 <code>source/images/</code> 目录下，这样在 Hexo 构建时会自动复制到 <code>public/images/</code> 中，路径清晰、引用方便。</p><h2 id="✏️-Markdown-插图语法示例"><a href="#✏️-Markdown-插图语法示例" class="headerlink" title="✏️ Markdown 插图语法示例"></a>✏️ Markdown 插图语法示例</h2><p>在 Markdown 中插入图片，我采用的是标准语法：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">评论区截图</span>](<span class="link">/images/comment-preview.png</span>)</span><br></pre></td></tr></table></figure><p>图片路径是以 <code>/images/</code> 开头的绝对路径，对应的是构建后 <code>public/images/</code> 中的资源。</p><h2 id="🔍-本地预览验证方法"><a href="#🔍-本地预览验证方法" class="headerlink" title="🔍 本地预览验证方法"></a>🔍 本地预览验证方法</h2><p>执行以下命令后，可以本地预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>浏览器打开 <code>http://localhost:4000/</code> 后，文章内图片能正常显示。也可以直接访问图片链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/images/comment-preview.png</span><br></pre></td></tr></table></figure><p>如果图片能单独访问，但在文章里不显示，那就要检查是否用了相对路径、或者图片链接是否打错。</p><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>Hexo 插图其实不复杂，只要把图片放在 <code>source/</code> 下，并使用正确路径，就可以稳定地显示。<br>以后写文时，我都会统一放在 <code>source/images/</code>，省心不少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;🗃️-图片存放位置的选择&quot;&gt;&lt;a href=&quot;#🗃️-图片存放位置的选择&quot; class=&quot;headerlink&quot; title=&quot;🗃️ 图片存放位置的选择&quot;&gt;&lt;/a&gt;🗃️ 图片存放位置的选择&lt;/h2&gt;&lt;p&gt;我将图片统一放在了博客项目的 &lt;code&gt;sourc</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Markdown" scheme="https://ai.he0xwhale.xyz/tags/Markdown/"/>
    
    <category term="插图" scheme="https://ai.he0xwhale.xyz/tags/%E6%8F%92%E5%9B%BE/"/>
    
    <category term="博客技巧" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中添加分类、标签、关于、友链页面的完整教程（Volantis 主题）</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/11/hexo-volantis-add-pages-guide/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/11/hexo-volantis-add-pages-guide/</id>
    <published>2025-06-11T04:00:00.000Z</published>
    <updated>2025-07-08T03:17:12.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Volantis-添加常用页面指南"><a href="#Hexo-Volantis-添加常用页面指南" class="headerlink" title="Hexo Volantis 添加常用页面指南"></a>Hexo Volantis 添加常用页面指南</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在搭建 Hexo 博客并使用 Volantis 主题时，很多人会遇到访问 <code>/categories/</code>、<code>/tags/</code>、<code>/about/</code> 或 <code>/friends/</code> 页面时提示 <code>Cannot GET</code> 的问题。本文将手把手教你如何手动添加这些页面并正确配置它们的 front-matter，从而让博客结构更完整，功能更齐全。</p><h2 id="一、添加分类页面（-categories-）"><a href="#一、添加分类页面（-categories-）" class="headerlink" title="一、添加分类页面（&#x2F;categories&#x2F;）"></a>一、添加分类页面（&#x2F;categories&#x2F;）</h2><h3 id="1-安装插件（如未安装）"><a href="#1-安装插件（如未安装）" class="headerlink" title="1. 安装插件（如未安装）"></a>1. 安装插件（如未安装）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-category --save</span><br></pre></td></tr></table></figure><h3 id="2-创建页面"><a href="#2-创建页面" class="headerlink" title="2. 创建页面"></a>2. 创建页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><h3 id="3-修改-front-matter"><a href="#3-修改-front-matter" class="headerlink" title="3. 修改 front-matter"></a>3. 修改 front-matter</h3><p>编辑 <code>source/categories/index.md</code> 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">category</span></span><br><span class="line"><span class="attr">index:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="4-重建博客"><a href="#4-重建博客" class="headerlink" title="4. 重建博客"></a>4. 重建博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="5-访问验证"><a href="#5-访问验证" class="headerlink" title="5. 访问验证"></a>5. 访问验证</h3><p>浏览器访问：<a href="http://localhost:4000/categories/">http://localhost:4000/categories/</a></p><h2 id="二、添加标签页面（-tags-）"><a href="#二、添加标签页面（-tags-）" class="headerlink" title="二、添加标签页面（&#x2F;tags&#x2F;）"></a>二、添加标签页面（&#x2F;tags&#x2F;）</h2><h3 id="1-创建页面"><a href="#1-创建页面" class="headerlink" title="1. 创建页面"></a>1. 创建页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><h3 id="2-修改-front-matter"><a href="#2-修改-front-matter" class="headerlink" title="2. 修改 front-matter"></a>2. 修改 front-matter</h3><p>编辑 <code>source/tags/index.md</code> 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">tag</span></span><br><span class="line"><span class="attr">index:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="3-重新生成并访问"><a href="#3-重新生成并访问" class="headerlink" title="3. 重新生成并访问"></a>3. 重新生成并访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:4000/tags/">http://localhost:4000/tags/</a></p><h2 id="三、添加关于页面（-about-）"><a href="#三、添加关于页面（-about-）" class="headerlink" title="三、添加关于页面（&#x2F;about&#x2F;）"></a>三、添加关于页面（&#x2F;about&#x2F;）</h2><h3 id="1-创建页面-1"><a href="#1-创建页面-1" class="headerlink" title="1. 创建页面"></a>1. 创建页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h3 id="2-编辑-front-matter-和正文"><a href="#2-编辑-front-matter-和正文" class="headerlink" title="2. 编辑 front-matter 和正文"></a>2. 编辑 front-matter 和正文</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于我</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">page</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">你好，我是</span> <span class="string">XXX。欢迎来到我的博客。</span></span><br></pre></td></tr></table></figure><h3 id="3-访问验证"><a href="#3-访问验证" class="headerlink" title="3. 访问验证"></a>3. 访问验证</h3><p>浏览器访问：<a href="http://localhost:4000/about/">http://localhost:4000/about/</a></p><h2 id="四、添加友链页面（-friends-）"><a href="#四、添加友链页面（-friends-）" class="headerlink" title="四、添加友链页面（&#x2F;friends&#x2F;）"></a>四、添加友链页面（&#x2F;friends&#x2F;）</h2><h3 id="1-创建页面-2"><a href="#1-创建页面-2" class="headerlink" title="1. 创建页面"></a>1. 创建页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure><h3 id="2-编辑-front-matter-和内容"><a href="#2-编辑-front-matter-和内容" class="headerlink" title="2. 编辑 front-matter 和内容"></a>2. 编辑 front-matter 和内容</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">友链</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">page</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">欢迎交换友链，请留言或联系我。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 友情链接</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">Hexo</span> <span class="string">官方文档</span>]<span class="string">(https://hexo.io/)</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">Volantis</span> <span class="string">主题文档</span>]<span class="string">(https://volantis.js.org/)</span></span><br></pre></td></tr></table></figure><h3 id="3-可选：使用卡片式展示"><a href="#3-可选：使用卡片式展示" class="headerlink" title="3. 可选：使用卡片式展示"></a>3. 可选：使用卡片式展示</h3><p>Volantis 支持自定义 <code>friends.yml</code> 数据文件，可配合自定义模板实现卡片式展示。</p><h2 id="五、常见问题与总结"><a href="#五、常见问题与总结" class="headerlink" title="五、常见问题与总结"></a>五、常见问题与总结</h2><h3 id="页面生成了但访问仍然报错？"><a href="#页面生成了但访问仍然报错？" class="headerlink" title="页面生成了但访问仍然报错？"></a>页面生成了但访问仍然报错？</h3><p>请检查：</p><ul><li><code>source/xxx/index.md</code> 文件是否存在</li><li>front-matter 是否写错字段（必须包含 <code>layout: xxx</code> 和 <code>index: true</code>）</li><li>是否执行了 <code>hexo clean &amp;&amp; hexo g</code></li></ul><h3 id="Volantis-支持的-layout-对照表："><a href="#Volantis-支持的-layout-对照表：" class="headerlink" title="Volantis 支持的 layout 对照表："></a>Volantis 支持的 layout 对照表：</h3><table><thead><tr><th>页面类型</th><th>layout 值</th></tr></thead><tbody><tr><td>分类页</td><td>category</td></tr><tr><td>标签页</td><td>tag</td></tr><tr><td>关于页</td><td>page</td></tr><tr><td>友链页</td><td>page</td></tr></tbody></table><h2 id="附录：页面文件结构参考"><a href="#附录：页面文件结构参考" class="headerlink" title="附录：页面文件结构参考"></a>附录：页面文件结构参考</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source/</span><br><span class="line">├── about/</span><br><span class="line">│   └── index.md</span><br><span class="line">├── categories/</span><br><span class="line">│   └── index.md</span><br><span class="line">├── tags/</span><br><span class="line">│   └── index.md</span><br><span class="line">├── friends/</span><br><span class="line">│   └── index.md</span><br></pre></td></tr></table></figure><p>生成后的页面会在 <code>public/</code> 目录中对应生成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-Volantis-添加常用页面指南&quot;&gt;&lt;a href=&quot;#Hexo-Volantis-添加常用页面指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo Volantis 添加常用页面指南&quot;&gt;&lt;/a&gt;Hexo Volantis 添加常用页面</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="Volantis" scheme="https://ai.he0xwhale.xyz/tags/Volantis/"/>
    
    <category term="博客页面" scheme="https://ai.he0xwhale.xyz/tags/%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/"/>
    
    <category term="分类标签" scheme="https://ai.he0xwhale.xyz/tags/%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE/"/>
    
    <category term="友链页面" scheme="https://ai.he0xwhale.xyz/tags/%E5%8F%8B%E9%93%BE%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客中集成 Giscus 评论系统的实践记录</title>
    <link href="https://ai.he0xwhale.xyz/2025/06/10/hexo_giscus_setup/"/>
    <id>https://ai.he0xwhale.xyz/2025/06/10/hexo_giscus_setup/</id>
    <published>2025-06-10T10:00:00.000Z</published>
    <updated>2025-07-08T03:15:49.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-集成-Giscus-评论系统完整指南"><a href="#Hexo-集成-Giscus-评论系统完整指南" class="headerlink" title="Hexo 集成 Giscus 评论系统完整指南"></a>Hexo 集成 Giscus 评论系统完整指南</h1><h2 id="📘-一、Giscus-简介"><a href="#📘-一、Giscus-简介" class="headerlink" title="📘 一、Giscus 简介"></a>📘 一、Giscus 简介</h2><p>Giscus 是一个基于 GitHub Discussions 的现代评论系统，支持 Markdown、暗黑模式、Reactions，并通过 GitHub OAuth 实现身份识别。它不需要额外数据库，适用于技术博客、文档站点等。</p><p>volantis默认支持 Giscus，所以选择了这个插件系统。</p><hr><h2 id="🚀-二、准备工作"><a href="#🚀-二、准备工作" class="headerlink" title="🚀 二、准备工作"></a>🚀 二、准备工作</h2><h3 id="2-1-拥有一个公开-GitHub-仓库"><a href="#2-1-拥有一个公开-GitHub-仓库" class="headerlink" title="2.1 拥有一个公开 GitHub 仓库"></a>2.1 拥有一个公开 GitHub 仓库</h3><p>确保你的博客源代码所在的仓库是公开的。</p><h3 id="2-2-Hexo-安装与主题准备"><a href="#2-2-Hexo-安装与主题准备" class="headerlink" title="2.2 Hexo 安装与主题准备"></a>2.2 Hexo 安装与主题准备</h3><p>本文以 Volantis 主题为例，你应已完成以下操作：</p><ul><li>安装 Hexo</li><li>配置并使用 Volantis 主题</li><li>启用 Hexo 的 deploy 功能（如 <code>hexo-deployer-git</code>）</li></ul><hr><h2 id="🔧-三、GitHub-端配置"><a href="#🔧-三、GitHub-端配置" class="headerlink" title="🔧 三、GitHub 端配置"></a>🔧 三、GitHub 端配置</h2><h3 id="3-1-启用-Discussions-功能"><a href="#3-1-启用-Discussions-功能" class="headerlink" title="3.1 启用 Discussions 功能"></a>3.1 启用 Discussions 功能</h3><ol><li>进入你的 GitHub 仓库主页</li><li>点击菜单栏的【Settings】→ 左侧【Features】 → 勾选 <strong>Discussions</strong></li></ol><h3 id="3-2-创建-Discussion-分类"><a href="#3-2-创建-Discussion-分类" class="headerlink" title="3.2 创建 Discussion 分类"></a>3.2 创建 Discussion 分类</h3><ol><li>打开仓库的 Discussions 页面</li><li>点击右上角 <strong>⚙️ Settings</strong></li><li>创建一个新分类，建议类型为 <strong>Announcements</strong></li><li>复制该分类的名称（如 <code>General</code>）和 ID（通过 giscus.app 获取）</li></ol><h3 id="3-3-安装-Giscus-GitHub-App"><a href="#3-3-安装-Giscus-GitHub-App" class="headerlink" title="3.3 安装 Giscus GitHub App"></a>3.3 安装 Giscus GitHub App</h3><ol><li>打开 <a href="https://github.com/apps/giscus">https://github.com/apps/giscus</a></li><li>点击【Install】</li><li>选择你博客所用的仓库进行授权</li></ol><hr><h2 id="⚙️-四、使用-Giscus-配置生成器"><a href="#⚙️-四、使用-Giscus-配置生成器" class="headerlink" title="⚙️ 四、使用 Giscus 配置生成器"></a>⚙️ 四、使用 Giscus 配置生成器</h2><p>访问 <a href="https://giscus.app/">https://giscus.app</a> 进行配置：</p><ul><li><strong>Repository</strong>：填写 <code>yourname/yourrepo</code></li><li><strong>Category</strong>：选择刚才创建的分类</li><li><strong>Mapping</strong>：选择 <code>pathname</code>（推荐）</li><li><strong>Input position</strong>：选择 <code>Top</code></li><li><strong>Theme</strong>：<code>light</code> 或 <code>preferred_color_scheme</code></li><li><strong>Language</strong>：选择 <code>zh-CN</code></li></ul><h3 id="建议启用的特性"><a href="#建议启用的特性" class="headerlink" title="建议启用的特性"></a>建议启用的特性</h3><ul><li>✅ Enable reactions for the main post</li><li>✅ Load the comments lazily</li><li>❌ Emit discussion metadata（一般不必）</li><li>✅ Place the comment box above the comments</li></ul><p>点击底部【Copy code】，复制生成的配置 JSON 内容。</p><hr><h2 id="🛠️-五、Hexo-中集成-Giscus（Volantis-主题）"><a href="#🛠️-五、Hexo-中集成-Giscus（Volantis-主题）" class="headerlink" title="🛠️ 五、Hexo 中集成 Giscus（Volantis 主题）"></a>🛠️ 五、Hexo 中集成 Giscus（Volantis 主题）</h2><h3 id="5-1-配置主题文件"><a href="#5-1-配置主题文件" class="headerlink" title="5.1 配置主题文件"></a>5.1 配置主题文件</h3><p>编辑文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes/volantis/layout/_plugins/comments/giscus/script.ejs</span><br></pre></td></tr></table></figure><p>确认已有以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  volantis.<span class="title function_">layoutHelper</span>(<span class="string">&quot;comments&quot;</span>,<span class="string">`&lt;div id=&quot;giscus_container&quot;&gt;&lt;/div&gt;`</span>)</span></span><br><span class="line"><span class="language-javascript">  volantis.<span class="property">giscus</span> = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">check_giscus</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (volantis.<span class="property">dark</span>.<span class="property">mode</span> === <span class="string">&quot;dark&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      volantis.<span class="property">giscus</span>.<span class="property">Theme</span> = <span class="string">&#x27;&lt;%- theme.comments.giscus.theme.dark %&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      volantis.<span class="property">giscus</span>.<span class="property">Theme</span> = <span class="string">&#x27;&lt;%- theme.comments.giscus.theme.light %&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;giscus_container&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">p_giscus</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">HEAD</span> = <span class="title function_">check_giscus</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!<span class="variable constant_">HEAD</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> cfg = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&lt;%- <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(theme.<span class="property">comments</span>.<span class="property">giscus</span>) %&gt;,pdata.<span class="property">commentConfig</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;https://giscus.app/client.js&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(cfg).<span class="title function_">forEach</span>(<span class="function"><span class="params">k</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (k != <span class="string">&quot;theme&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-&#x27;</span>+k, cfg[k]);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>, volantis.<span class="property">giscus</span>.<span class="property">Theme</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossorigin&#x27;</span>, <span class="string">&quot;anonymous&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable constant_">HEAD</span>.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">dark_giscus</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">HEAD</span> = <span class="title function_">check_giscus</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!<span class="variable constant_">HEAD</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> message = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">setConfig</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">theme</span>: volantis.<span class="property">giscus</span>.<span class="property">Theme</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> giscusIframe = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;iframe.giscus-frame&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    giscusIframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">giscus</span>: message &#125;, <span class="string">&#x27;https://giscus.app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">p_giscus</span>();</span></span><br><span class="line"><span class="language-javascript">  volantis.<span class="property">dark</span>.<span class="title function_">push</span>(dark_giscus);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-主题配置文件-config-yml-theme目录下的"><a href="#5-2-主题配置文件-config-yml-theme目录下的" class="headerlink" title="5.2 主题配置文件 _config.yml (theme目录下的)"></a>5.2 主题配置文件 <code>_config.yml</code> (theme目录下的)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">giscus:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">yourname/yourrepo</span></span><br><span class="line">    <span class="attr">repo-id:</span> <span class="string">YOUR_REPO_ID</span></span><br><span class="line">    <span class="attr">category:</span> <span class="string">General</span></span><br><span class="line">    <span class="attr">category-id:</span> <span class="string">YOUR_CATEGORY_ID</span></span><br><span class="line">    <span class="attr">mapping:</span> <span class="string">pathname</span></span><br><span class="line">    <span class="attr">strict:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">reactions-enabled:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">emit-metadata:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">input-position:</span> <span class="string">top</span></span><br><span class="line">    <span class="attr">theme:</span></span><br><span class="line">      <span class="attr">light:</span> <span class="string">light</span></span><br><span class="line">      <span class="attr">dark:</span> <span class="string">dark_dimmed</span></span><br><span class="line">    <span class="attr">lang:</span> <span class="string">zh-CN</span></span><br><span class="line">    <span class="attr">loading:</span> <span class="string">lazy</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧪-六、本地调试与错误排查"><a href="#🧪-六、本地调试与错误排查" class="headerlink" title="🧪 六、本地调试与错误排查"></a>🧪 六、本地调试与错误排查</h2><p>在调试过程中，我遇到了一些比较典型的问题，这里记录下来以供参考。</p><h3 id="6-1-常见问题"><a href="#6-1-常见问题" class="headerlink" title="6.1 常见问题"></a>6.1 常见问题</h3><ul><li><p><strong>An error occurred: giscus is not installed on this repository</strong></p><p>一开始我没注意到要安装 Giscus 的 GitHub App，导致一直报这个错。后来在 <a href="https://github.com/apps/giscus">https://github.com/apps/giscus</a> 页面安装之后问题解决了。</p></li><li><p><strong>403 Forbidden: repo&#x3D;undefined</strong></p><p>这个问题出现在我忘记正确填写主题配置文件中的 <code>repo</code> 和 <code>repo-id</code>。另外要注意，相关配置必须写在 <code>themes/volantis/_config.yml</code> 中，而不是_config.volantis.yml文件。</p></li></ul><hr><h2 id="📤-七、部署与-Git-提交"><a href="#📤-七、部署与-Git-提交" class="headerlink" title="📤 七、部署与 Git 提交"></a>📤 七、部署与 Git 提交</h2><p>使用以下 <code>deploy.sh</code> 自动部署脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🧹 Cleaning cache and public folder...&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📦 Generating static files...&quot;</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🚀 Deploying to GitHub Pages...&quot;</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ Hexo deploy finished.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交 source 源码（包含主题子模块）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📁 Committing source code...&quot;</span></span><br><span class="line">git submodule foreach <span class="string">&#x27;git add . &amp;&amp; git commit -m &quot;update submodule&quot; || echo &quot;No changes in submodule&quot;&#x27;</span></span><br><span class="line">git add .</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;📝 Enter commit message: &quot;</span> msg</span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$msg</span>&quot;</span></span><br><span class="line">git push origin main</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🎉 All done!&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="✅-八、效果预览与总结"><a href="#✅-八、效果预览与总结" class="headerlink" title="✅ 八、效果预览与总结"></a>✅ 八、效果预览与总结</h2><p>在部署完成后，我访问了博客页面，Giscus 评论区成功加载。它的加载速度很快，界面简洁，支持登录用户互动，还能显示 emoji reactions。<br><img src="/images/comment-preview.png" alt="GISCUS 效果预览"></p><p>这次集成体验整体比较顺利，唯一花时间的是理清配置的几个关键点。整体来看，Giscus 的无后端、无广告、与 GitHub 无缝集成等特点，非常契合我的博客需求。如果你也在使用 Hexo 搭建博客，不妨也试试 Giscus —— 搭起来其实没那么难。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-集成-Giscus-评论系统完整指南&quot;&gt;&lt;a href=&quot;#Hexo-集成-Giscus-评论系统完整指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo 集成 Giscus 评论系统完整指南&quot;&gt;&lt;/a&gt;Hexo 集成 Giscus 评论</summary>
      
    
    
    
    <category term="博客之旅" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
    
    <category term="基础搭建" scheme="https://ai.he0xwhale.xyz/categories/%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://ai.he0xwhale.xyz/tags/Hexo/"/>
    
    <category term="评论系统" scheme="https://ai.he0xwhale.xyz/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Giscus" scheme="https://ai.he0xwhale.xyz/tags/Giscus/"/>
    
    <category term="GitHub Discussions" scheme="https://ai.he0xwhale.xyz/tags/GitHub-Discussions/"/>
    
  </entry>
  
</feed>
